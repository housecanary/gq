// Code generated from /Users/mpoindexter/dev/gq/grammar/Graphql.g4 by ANTLR 4.12.0. DO NOT EDIT.

package gen // Graphql
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type GraphqlParser struct {
	*antlr.BaseParser
}

var graphqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func graphqlParserInit() {
	staticData := &graphqlParserStaticData
	staticData.literalNames = []string{
		"", "'['", "']'", "'{'", "'}'", "':'", "'@'", "'('", "')'", "'$'", "'='",
		"'!'", "'...'", "'&'", "'|'", "", "'null'", "'fragment'", "'query'",
		"'mutation'", "'subscription'", "'schema'", "'scalar'", "'type'", "'interface'",
		"'implements'", "'enum'", "'union'", "'input'", "'extend'", "'directive'",
		"'on'", "'repeatable'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BooleanValue",
		"NullValue", "FRAGMENT", "QUERY", "MUTATION", "SUBSCRIPTION", "SCHEMA",
		"SCALAR", "TYPE", "INTERFACE", "IMPLEMENTS", "ENUM", "UNION", "INPUT",
		"EXTEND", "DIRECTIVE", "ON_KEYWORD", "REPEATABLE", "NAME", "IntValue",
		"FloatValue", "StringValue", "Ignored",
	}
	staticData.ruleNames = []string{
		"operationType", "description", "enumValue", "arrayValue", "arrayValueWithVariable",
		"objectValue", "objectValueWithVariable", "objectField", "objectFieldWithVariable",
		"directives", "directive", "arguments", "argument", "baseName", "fragmentName",
		"enumValueName", "name", "value", "valueWithVariable", "variable", "defaultValue",
		"gqlType", "typeName", "listType", "nonNullType", "operationDefinition",
		"variableDefinitions", "variableDefinition", "selectionSet", "selection",
		"field", "alias", "fragmentSpread", "inlineFragment", "fragmentDefinition",
		"typeCondition", "document", "typeSystemDefinition", "typeSystemExtension",
		"schemaDefinition", "schemaExtension", "operationTypeDefinition", "typeDefinition",
		"typeExtension", "emptyParentheses", "scalarTypeDefinition", "scalarTypeExtensionDefinition",
		"objectTypeDefinition", "objectTypeExtensionDefinition", "implementsInterfaces",
		"fieldsDefinition", "extensionFieldsDefinition", "fieldDefinition",
		"argumentsDefinition", "inputValueDefinition", "interfaceTypeDefinition",
		"interfaceTypeExtensionDefinition", "unionTypeDefinition", "unionTypeExtensionDefinition",
		"unionMembership", "unionMembers", "enumTypeDefinition", "enumTypeExtensionDefinition",
		"enumValueDefinitions", "extensionEnumValueDefinitions", "enumValueDefinition",
		"inputObjectTypeDefinition", "inputObjectTypeExtensionDefinition", "inputObjectValueDefinitions",
		"extensionInputObjectValueDefinitions", "directiveDefinition", "directiveLocation",
		"directiveLocations", "partialFieldDefinition", "partialObjectTypeDefinition",
		"partialInputObjectTypeDefinition", "partialInputValueDefinition", "partialEnumTypeDefinition",
		"partialInterfaceTypeDefinition", "partialUnionTypeDefinition", "partialScalarTypeDefinition",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 37, 1043, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1,
		3, 5, 3, 171, 8, 3, 10, 3, 12, 3, 174, 9, 3, 1, 3, 1, 3, 1, 4, 1, 4, 5,
		4, 180, 8, 4, 10, 4, 12, 4, 183, 9, 4, 1, 4, 1, 4, 1, 5, 1, 5, 5, 5, 189,
		8, 5, 10, 5, 12, 5, 192, 9, 5, 1, 5, 1, 5, 1, 6, 1, 6, 5, 6, 198, 8, 6,
		10, 6, 12, 6, 201, 9, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 9, 4, 9, 214, 8, 9, 11, 9, 12, 9, 215, 1, 10, 1, 10, 1,
		10, 3, 10, 221, 8, 10, 1, 11, 1, 11, 4, 11, 225, 8, 11, 11, 11, 12, 11,
		226, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1,
		14, 1, 14, 3, 14, 240, 8, 14, 1, 15, 1, 15, 3, 15, 244, 8, 15, 1, 16, 1,
		16, 1, 16, 1, 16, 3, 16, 250, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 260, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 271, 8, 18, 1, 19, 1, 19, 1, 19,
		1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 3, 21, 282, 8, 21, 1, 22, 1,
		22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		3, 24, 296, 8, 24, 1, 25, 1, 25, 1, 25, 3, 25, 301, 8, 25, 1, 25, 3, 25,
		304, 8, 25, 1, 25, 3, 25, 307, 8, 25, 1, 25, 1, 25, 3, 25, 311, 8, 25,
		1, 26, 1, 26, 4, 26, 315, 8, 26, 11, 26, 12, 26, 316, 1, 26, 1, 26, 1,
		27, 1, 27, 1, 27, 1, 27, 3, 27, 325, 8, 27, 1, 27, 3, 27, 328, 8, 27, 1,
		28, 1, 28, 4, 28, 332, 8, 28, 11, 28, 12, 28, 333, 1, 28, 1, 28, 1, 29,
		1, 29, 1, 29, 3, 29, 341, 8, 29, 1, 30, 3, 30, 344, 8, 30, 1, 30, 1, 30,
		3, 30, 348, 8, 30, 1, 30, 3, 30, 351, 8, 30, 1, 30, 3, 30, 354, 8, 30,
		1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 3, 32, 362, 8, 32, 1, 33, 1,
		33, 3, 33, 366, 8, 33, 1, 33, 3, 33, 369, 8, 33, 1, 33, 1, 33, 1, 34, 1,
		34, 1, 34, 1, 34, 3, 34, 377, 8, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		1, 36, 1, 36, 4, 36, 386, 8, 36, 11, 36, 12, 36, 387, 1, 37, 1, 37, 1,
		37, 3, 37, 393, 8, 37, 1, 38, 1, 38, 3, 38, 397, 8, 38, 1, 39, 3, 39, 400,
		8, 39, 1, 39, 1, 39, 3, 39, 404, 8, 39, 1, 39, 1, 39, 4, 39, 408, 8, 39,
		11, 39, 12, 39, 409, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 3, 40, 417, 8,
		40, 1, 40, 1, 40, 4, 40, 421, 8, 40, 11, 40, 12, 40, 422, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 4, 40, 430, 8, 40, 11, 40, 12, 40, 431, 3, 40, 434,
		8, 40, 1, 41, 3, 41, 437, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 449, 8, 42, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 3, 43, 457, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 3,
		45, 463, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 468, 8, 45, 1, 46, 1, 46, 1,
		46, 1, 46, 3, 46, 474, 8, 46, 1, 47, 3, 47, 477, 8, 47, 1, 47, 1, 47, 1,
		47, 3, 47, 482, 8, 47, 1, 47, 3, 47, 485, 8, 47, 1, 47, 3, 47, 488, 8,
		47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 494, 8, 48, 1, 48, 3, 48, 497, 8,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 505, 8, 48, 1, 48,
		1, 48, 3, 48, 509, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 516,
		8, 48, 1, 49, 1, 49, 1, 49, 3, 49, 521, 8, 49, 1, 49, 4, 49, 524, 8, 49,
		11, 49, 12, 49, 525, 1, 49, 1, 49, 1, 49, 5, 49, 531, 8, 49, 10, 49, 12,
		49, 534, 9, 49, 1, 50, 1, 50, 5, 50, 538, 8, 50, 10, 50, 12, 50, 541, 9,
		50, 1, 50, 1, 50, 1, 51, 1, 51, 4, 51, 547, 8, 51, 11, 51, 12, 51, 548,
		1, 51, 1, 51, 1, 52, 3, 52, 554, 8, 52, 1, 52, 1, 52, 3, 52, 558, 8, 52,
		1, 52, 1, 52, 1, 52, 3, 52, 563, 8, 52, 1, 53, 1, 53, 4, 53, 567, 8, 53,
		11, 53, 12, 53, 568, 1, 53, 1, 53, 1, 54, 3, 54, 574, 8, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 3, 54, 580, 8, 54, 1, 54, 3, 54, 583, 8, 54, 1, 55, 3,
		55, 586, 8, 55, 1, 55, 1, 55, 1, 55, 3, 55, 591, 8, 55, 1, 55, 3, 55, 594,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 600, 8, 56, 1, 56, 3, 56, 603,
		8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 611, 8, 56, 1,
		56, 1, 56, 3, 56, 615, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56,
		622, 8, 56, 1, 57, 3, 57, 625, 8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 630,
		8, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 638, 8, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 647, 8, 58, 1, 59,
		1, 59, 1, 59, 1, 60, 1, 60, 3, 60, 654, 8, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 5, 60, 661, 8, 60, 10, 60, 12, 60, 664, 9, 60, 1, 61, 3, 61,
		667, 8, 61, 1, 61, 1, 61, 1, 61, 3, 61, 672, 8, 61, 1, 61, 3, 61, 675,
		8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 681, 8, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 690, 8, 62, 3, 62, 692, 8, 62, 1,
		63, 1, 63, 5, 63, 696, 8, 63, 10, 63, 12, 63, 699, 9, 63, 1, 63, 1, 63,
		1, 64, 1, 64, 4, 64, 705, 8, 64, 11, 64, 12, 64, 706, 1, 64, 1, 64, 1,
		65, 3, 65, 712, 8, 65, 1, 65, 1, 65, 3, 65, 716, 8, 65, 1, 66, 3, 66, 719,
		8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 724, 8, 66, 1, 66, 3, 66, 727, 8, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 733, 8, 67, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 3, 67, 742, 8, 67, 3, 67, 744, 8, 67, 1, 68, 1,
		68, 5, 68, 748, 8, 68, 10, 68, 12, 68, 751, 9, 68, 1, 68, 1, 68, 1, 69,
		1, 69, 4, 69, 757, 8, 69, 11, 69, 12, 69, 758, 1, 69, 1, 69, 1, 70, 3,
		70, 764, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 770, 8, 70, 1, 70, 3,
		70, 773, 8, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 3, 72,
		782, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 789, 8, 72, 10, 72,
		12, 72, 792, 9, 72, 1, 73, 1, 73, 3, 73, 796, 8, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 801, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 807, 8, 73, 1, 73,
		1, 73, 3, 73, 811, 8, 73, 1, 73, 3, 73, 814, 8, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 819, 8, 73, 1, 73, 1, 73, 3, 73, 823, 8, 73, 1, 74, 3, 74, 826,
		8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 831, 8, 74, 1, 74, 3, 74, 834, 8, 74,
		1, 74, 3, 74, 837, 8, 74, 1, 74, 3, 74, 840, 8, 74, 1, 74, 1, 74, 3, 74,
		844, 8, 74, 1, 74, 3, 74, 847, 8, 74, 1, 74, 3, 74, 850, 8, 74, 1, 74,
		3, 74, 853, 8, 74, 1, 74, 3, 74, 856, 8, 74, 1, 74, 3, 74, 859, 8, 74,
		1, 74, 3, 74, 862, 8, 74, 3, 74, 864, 8, 74, 1, 75, 3, 75, 867, 8, 75,
		1, 75, 1, 75, 1, 75, 3, 75, 872, 8, 75, 1, 75, 1, 75, 1, 75, 3, 75, 877,
		8, 75, 1, 75, 1, 75, 3, 75, 881, 8, 75, 1, 75, 1, 75, 1, 75, 3, 75, 886,
		8, 75, 1, 75, 3, 75, 889, 8, 75, 1, 75, 1, 75, 3, 75, 893, 8, 75, 1, 75,
		3, 75, 896, 8, 75, 3, 75, 898, 8, 75, 1, 76, 3, 76, 901, 8, 76, 1, 76,
		1, 76, 1, 76, 1, 76, 3, 76, 907, 8, 76, 1, 76, 3, 76, 910, 8, 76, 1, 76,
		3, 76, 913, 8, 76, 1, 76, 1, 76, 3, 76, 917, 8, 76, 1, 76, 3, 76, 920,
		8, 76, 1, 76, 3, 76, 923, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 928, 8, 76,
		1, 76, 3, 76, 931, 8, 76, 1, 76, 3, 76, 934, 8, 76, 1, 76, 1, 76, 3, 76,
		938, 8, 76, 1, 76, 3, 76, 941, 8, 76, 1, 76, 3, 76, 944, 8, 76, 1, 77,
		3, 77, 947, 8, 77, 1, 77, 1, 77, 1, 77, 3, 77, 952, 8, 77, 1, 77, 1, 77,
		1, 77, 3, 77, 957, 8, 77, 1, 77, 1, 77, 3, 77, 961, 8, 77, 1, 77, 1, 77,
		1, 77, 3, 77, 966, 8, 77, 1, 77, 3, 77, 969, 8, 77, 1, 77, 3, 77, 972,
		8, 77, 1, 78, 3, 78, 975, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 980, 8, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 985, 8, 78, 1, 78, 1, 78, 3, 78, 989, 8, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 994, 8, 78, 1, 78, 3, 78, 997, 8, 78, 1, 78,
		3, 78, 1000, 8, 78, 1, 79, 3, 79, 1003, 8, 79, 1, 79, 1, 79, 1, 79, 3,
		79, 1008, 8, 79, 1, 79, 3, 79, 1011, 8, 79, 1, 79, 3, 79, 1014, 8, 79,
		1, 79, 1, 79, 3, 79, 1018, 8, 79, 1, 79, 3, 79, 1021, 8, 79, 1, 79, 3,
		79, 1024, 8, 79, 1, 79, 3, 79, 1027, 8, 79, 1, 79, 3, 79, 1030, 8, 79,
		3, 79, 1032, 8, 79, 1, 80, 3, 80, 1035, 8, 80, 1, 80, 3, 80, 1038, 8, 80,
		1, 80, 3, 80, 1041, 8, 80, 1, 80, 0, 3, 98, 120, 144, 81, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 0, 2, 1, 0, 18, 20, 2, 0,
		17, 30, 32, 33, 1178, 0, 162, 1, 0, 0, 0, 2, 164, 1, 0, 0, 0, 4, 166, 1,
		0, 0, 0, 6, 168, 1, 0, 0, 0, 8, 177, 1, 0, 0, 0, 10, 186, 1, 0, 0, 0, 12,
		195, 1, 0, 0, 0, 14, 204, 1, 0, 0, 0, 16, 208, 1, 0, 0, 0, 18, 213, 1,
		0, 0, 0, 20, 217, 1, 0, 0, 0, 22, 222, 1, 0, 0, 0, 24, 230, 1, 0, 0, 0,
		26, 234, 1, 0, 0, 0, 28, 239, 1, 0, 0, 0, 30, 243, 1, 0, 0, 0, 32, 249,
		1, 0, 0, 0, 34, 259, 1, 0, 0, 0, 36, 270, 1, 0, 0, 0, 38, 272, 1, 0, 0,
		0, 40, 275, 1, 0, 0, 0, 42, 281, 1, 0, 0, 0, 44, 283, 1, 0, 0, 0, 46, 285,
		1, 0, 0, 0, 48, 295, 1, 0, 0, 0, 50, 310, 1, 0, 0, 0, 52, 312, 1, 0, 0,
		0, 54, 320, 1, 0, 0, 0, 56, 329, 1, 0, 0, 0, 58, 340, 1, 0, 0, 0, 60, 343,
		1, 0, 0, 0, 62, 355, 1, 0, 0, 0, 64, 358, 1, 0, 0, 0, 66, 363, 1, 0, 0,
		0, 68, 372, 1, 0, 0, 0, 70, 380, 1, 0, 0, 0, 72, 385, 1, 0, 0, 0, 74, 392,
		1, 0, 0, 0, 76, 396, 1, 0, 0, 0, 78, 399, 1, 0, 0, 0, 80, 433, 1, 0, 0,
		0, 82, 436, 1, 0, 0, 0, 84, 448, 1, 0, 0, 0, 86, 456, 1, 0, 0, 0, 88, 458,
		1, 0, 0, 0, 90, 462, 1, 0, 0, 0, 92, 469, 1, 0, 0, 0, 94, 476, 1, 0, 0,
		0, 96, 515, 1, 0, 0, 0, 98, 517, 1, 0, 0, 0, 100, 535, 1, 0, 0, 0, 102,
		544, 1, 0, 0, 0, 104, 553, 1, 0, 0, 0, 106, 564, 1, 0, 0, 0, 108, 573,
		1, 0, 0, 0, 110, 585, 1, 0, 0, 0, 112, 621, 1, 0, 0, 0, 114, 624, 1, 0,
		0, 0, 116, 646, 1, 0, 0, 0, 118, 648, 1, 0, 0, 0, 120, 651, 1, 0, 0, 0,
		122, 666, 1, 0, 0, 0, 124, 691, 1, 0, 0, 0, 126, 693, 1, 0, 0, 0, 128,
		702, 1, 0, 0, 0, 130, 711, 1, 0, 0, 0, 132, 718, 1, 0, 0, 0, 134, 743,
		1, 0, 0, 0, 136, 745, 1, 0, 0, 0, 138, 754, 1, 0, 0, 0, 140, 763, 1, 0,
		0, 0, 142, 777, 1, 0, 0, 0, 144, 779, 1, 0, 0, 0, 146, 822, 1, 0, 0, 0,
		148, 863, 1, 0, 0, 0, 150, 897, 1, 0, 0, 0, 152, 943, 1, 0, 0, 0, 154,
		971, 1, 0, 0, 0, 156, 999, 1, 0, 0, 0, 158, 1031, 1, 0, 0, 0, 160, 1034,
		1, 0, 0, 0, 162, 163, 7, 0, 0, 0, 163, 1, 1, 0, 0, 0, 164, 165, 5, 36,
		0, 0, 165, 3, 1, 0, 0, 0, 166, 167, 3, 30, 15, 0, 167, 5, 1, 0, 0, 0, 168,
		172, 5, 1, 0, 0, 169, 171, 3, 34, 17, 0, 170, 169, 1, 0, 0, 0, 171, 174,
		1, 0, 0, 0, 172, 170, 1, 0, 0, 0, 172, 173, 1, 0, 0, 0, 173, 175, 1, 0,
		0, 0, 174, 172, 1, 0, 0, 0, 175, 176, 5, 2, 0, 0, 176, 7, 1, 0, 0, 0, 177,
		181, 5, 1, 0, 0, 178, 180, 3, 36, 18, 0, 179, 178, 1, 0, 0, 0, 180, 183,
		1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 184, 1, 0,
		0, 0, 183, 181, 1, 0, 0, 0, 184, 185, 5, 2, 0, 0, 185, 9, 1, 0, 0, 0, 186,
		190, 5, 3, 0, 0, 187, 189, 3, 14, 7, 0, 188, 187, 1, 0, 0, 0, 189, 192,
		1, 0, 0, 0, 190, 188, 1, 0, 0, 0, 190, 191, 1, 0, 0, 0, 191, 193, 1, 0,
		0, 0, 192, 190, 1, 0, 0, 0, 193, 194, 5, 4, 0, 0, 194, 11, 1, 0, 0, 0,
		195, 199, 5, 3, 0, 0, 196, 198, 3, 16, 8, 0, 197, 196, 1, 0, 0, 0, 198,
		201, 1, 0, 0, 0, 199, 197, 1, 0, 0, 0, 199, 200, 1, 0, 0, 0, 200, 202,
		1, 0, 0, 0, 201, 199, 1, 0, 0, 0, 202, 203, 5, 4, 0, 0, 203, 13, 1, 0,
		0, 0, 204, 205, 3, 32, 16, 0, 205, 206, 5, 5, 0, 0, 206, 207, 3, 34, 17,
		0, 207, 15, 1, 0, 0, 0, 208, 209, 3, 32, 16, 0, 209, 210, 5, 5, 0, 0, 210,
		211, 3, 36, 18, 0, 211, 17, 1, 0, 0, 0, 212, 214, 3, 20, 10, 0, 213, 212,
		1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 215, 216, 1, 0,
		0, 0, 216, 19, 1, 0, 0, 0, 217, 218, 5, 6, 0, 0, 218, 220, 3, 32, 16, 0,
		219, 221, 3, 22, 11, 0, 220, 219, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221,
		21, 1, 0, 0, 0, 222, 224, 5, 7, 0, 0, 223, 225, 3, 24, 12, 0, 224, 223,
		1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 224, 1, 0, 0, 0, 226, 227, 1, 0,
		0, 0, 227, 228, 1, 0, 0, 0, 228, 229, 5, 8, 0, 0, 229, 23, 1, 0, 0, 0,
		230, 231, 3, 32, 16, 0, 231, 232, 5, 5, 0, 0, 232, 233, 3, 36, 18, 0, 233,
		25, 1, 0, 0, 0, 234, 235, 7, 1, 0, 0, 235, 27, 1, 0, 0, 0, 236, 240, 3,
		26, 13, 0, 237, 240, 5, 15, 0, 0, 238, 240, 5, 16, 0, 0, 239, 236, 1, 0,
		0, 0, 239, 237, 1, 0, 0, 0, 239, 238, 1, 0, 0, 0, 240, 29, 1, 0, 0, 0,
		241, 244, 3, 26, 13, 0, 242, 244, 5, 31, 0, 0, 243, 241, 1, 0, 0, 0, 243,
		242, 1, 0, 0, 0, 244, 31, 1, 0, 0, 0, 245, 250, 3, 26, 13, 0, 246, 250,
		5, 15, 0, 0, 247, 250, 5, 16, 0, 0, 248, 250, 5, 31, 0, 0, 249, 245, 1,
		0, 0, 0, 249, 246, 1, 0, 0, 0, 249, 247, 1, 0, 0, 0, 249, 248, 1, 0, 0,
		0, 250, 33, 1, 0, 0, 0, 251, 260, 5, 36, 0, 0, 252, 260, 5, 34, 0, 0, 253,
		260, 5, 35, 0, 0, 254, 260, 5, 15, 0, 0, 255, 260, 5, 16, 0, 0, 256, 260,
		3, 4, 2, 0, 257, 260, 3, 6, 3, 0, 258, 260, 3, 10, 5, 0, 259, 251, 1, 0,
		0, 0, 259, 252, 1, 0, 0, 0, 259, 253, 1, 0, 0, 0, 259, 254, 1, 0, 0, 0,
		259, 255, 1, 0, 0, 0, 259, 256, 1, 0, 0, 0, 259, 257, 1, 0, 0, 0, 259,
		258, 1, 0, 0, 0, 260, 35, 1, 0, 0, 0, 261, 271, 3, 38, 19, 0, 262, 271,
		5, 36, 0, 0, 263, 271, 5, 34, 0, 0, 264, 271, 5, 35, 0, 0, 265, 271, 5,
		15, 0, 0, 266, 271, 5, 16, 0, 0, 267, 271, 3, 4, 2, 0, 268, 271, 3, 8,
		4, 0, 269, 271, 3, 12, 6, 0, 270, 261, 1, 0, 0, 0, 270, 262, 1, 0, 0, 0,
		270, 263, 1, 0, 0, 0, 270, 264, 1, 0, 0, 0, 270, 265, 1, 0, 0, 0, 270,
		266, 1, 0, 0, 0, 270, 267, 1, 0, 0, 0, 270, 268, 1, 0, 0, 0, 270, 269,
		1, 0, 0, 0, 271, 37, 1, 0, 0, 0, 272, 273, 5, 9, 0, 0, 273, 274, 3, 32,
		16, 0, 274, 39, 1, 0, 0, 0, 275, 276, 5, 10, 0, 0, 276, 277, 3, 34, 17,
		0, 277, 41, 1, 0, 0, 0, 278, 282, 3, 44, 22, 0, 279, 282, 3, 46, 23, 0,
		280, 282, 3, 48, 24, 0, 281, 278, 1, 0, 0, 0, 281, 279, 1, 0, 0, 0, 281,
		280, 1, 0, 0, 0, 282, 43, 1, 0, 0, 0, 283, 284, 3, 32, 16, 0, 284, 45,
		1, 0, 0, 0, 285, 286, 5, 1, 0, 0, 286, 287, 3, 42, 21, 0, 287, 288, 5,
		2, 0, 0, 288, 47, 1, 0, 0, 0, 289, 290, 3, 44, 22, 0, 290, 291, 5, 11,
		0, 0, 291, 296, 1, 0, 0, 0, 292, 293, 3, 46, 23, 0, 293, 294, 5, 11, 0,
		0, 294, 296, 1, 0, 0, 0, 295, 289, 1, 0, 0, 0, 295, 292, 1, 0, 0, 0, 296,
		49, 1, 0, 0, 0, 297, 311, 3, 56, 28, 0, 298, 300, 3, 0, 0, 0, 299, 301,
		3, 32, 16, 0, 300, 299, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 303, 1,
		0, 0, 0, 302, 304, 3, 52, 26, 0, 303, 302, 1, 0, 0, 0, 303, 304, 1, 0,
		0, 0, 304, 306, 1, 0, 0, 0, 305, 307, 3, 18, 9, 0, 306, 305, 1, 0, 0, 0,
		306, 307, 1, 0, 0, 0, 307, 308, 1, 0, 0, 0, 308, 309, 3, 56, 28, 0, 309,
		311, 1, 0, 0, 0, 310, 297, 1, 0, 0, 0, 310, 298, 1, 0, 0, 0, 311, 51, 1,
		0, 0, 0, 312, 314, 5, 7, 0, 0, 313, 315, 3, 54, 27, 0, 314, 313, 1, 0,
		0, 0, 315, 316, 1, 0, 0, 0, 316, 314, 1, 0, 0, 0, 316, 317, 1, 0, 0, 0,
		317, 318, 1, 0, 0, 0, 318, 319, 5, 8, 0, 0, 319, 53, 1, 0, 0, 0, 320, 321,
		3, 38, 19, 0, 321, 322, 5, 5, 0, 0, 322, 324, 3, 42, 21, 0, 323, 325, 3,
		40, 20, 0, 324, 323, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 327, 1, 0,
		0, 0, 326, 328, 3, 18, 9, 0, 327, 326, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0,
		328, 55, 1, 0, 0, 0, 329, 331, 5, 3, 0, 0, 330, 332, 3, 58, 29, 0, 331,
		330, 1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333, 331, 1, 0, 0, 0, 333, 334,
		1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 336, 5, 4, 0, 0, 336, 57, 1, 0,
		0, 0, 337, 341, 3, 60, 30, 0, 338, 341, 3, 64, 32, 0, 339, 341, 3, 66,
		33, 0, 340, 337, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 340, 339, 1, 0, 0, 0,
		341, 59, 1, 0, 0, 0, 342, 344, 3, 62, 31, 0, 343, 342, 1, 0, 0, 0, 343,
		344, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 347, 3, 32, 16, 0, 346, 348,
		3, 22, 11, 0, 347, 346, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 350, 1,
		0, 0, 0, 349, 351, 3, 18, 9, 0, 350, 349, 1, 0, 0, 0, 350, 351, 1, 0, 0,
		0, 351, 353, 1, 0, 0, 0, 352, 354, 3, 56, 28, 0, 353, 352, 1, 0, 0, 0,
		353, 354, 1, 0, 0, 0, 354, 61, 1, 0, 0, 0, 355, 356, 3, 32, 16, 0, 356,
		357, 5, 5, 0, 0, 357, 63, 1, 0, 0, 0, 358, 359, 5, 12, 0, 0, 359, 361,
		3, 28, 14, 0, 360, 362, 3, 18, 9, 0, 361, 360, 1, 0, 0, 0, 361, 362, 1,
		0, 0, 0, 362, 65, 1, 0, 0, 0, 363, 365, 5, 12, 0, 0, 364, 366, 3, 70, 35,
		0, 365, 364, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 368, 1, 0, 0, 0, 367,
		369, 3, 18, 9, 0, 368, 367, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 370,
		1, 0, 0, 0, 370, 371, 3, 56, 28, 0, 371, 67, 1, 0, 0, 0, 372, 373, 5, 17,
		0, 0, 373, 374, 3, 28, 14, 0, 374, 376, 3, 70, 35, 0, 375, 377, 3, 18,
		9, 0, 376, 375, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0,
		378, 379, 3, 56, 28, 0, 379, 69, 1, 0, 0, 0, 380, 381, 5, 31, 0, 0, 381,
		382, 3, 44, 22, 0, 382, 71, 1, 0, 0, 0, 383, 386, 3, 50, 25, 0, 384, 386,
		3, 68, 34, 0, 385, 383, 1, 0, 0, 0, 385, 384, 1, 0, 0, 0, 386, 387, 1,
		0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 73, 1, 0, 0,
		0, 389, 393, 3, 78, 39, 0, 390, 393, 3, 84, 42, 0, 391, 393, 3, 140, 70,
		0, 392, 389, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392, 391, 1, 0, 0, 0, 393,
		75, 1, 0, 0, 0, 394, 397, 3, 80, 40, 0, 395, 397, 3, 86, 43, 0, 396, 394,
		1, 0, 0, 0, 396, 395, 1, 0, 0, 0, 397, 77, 1, 0, 0, 0, 398, 400, 3, 2,
		1, 0, 399, 398, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0,
		401, 403, 5, 21, 0, 0, 402, 404, 3, 18, 9, 0, 403, 402, 1, 0, 0, 0, 403,
		404, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 407, 5, 3, 0, 0, 406, 408,
		3, 82, 41, 0, 407, 406, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 407, 1,
		0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 412, 5, 4, 0,
		0, 412, 79, 1, 0, 0, 0, 413, 414, 5, 29, 0, 0, 414, 416, 5, 21, 0, 0, 415,
		417, 3, 18, 9, 0, 416, 415, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 418,
		1, 0, 0, 0, 418, 420, 5, 3, 0, 0, 419, 421, 3, 82, 41, 0, 420, 419, 1,
		0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 420, 1, 0, 0, 0, 422, 423, 1, 0, 0,
		0, 423, 424, 1, 0, 0, 0, 424, 425, 5, 4, 0, 0, 425, 434, 1, 0, 0, 0, 426,
		427, 5, 29, 0, 0, 427, 429, 5, 21, 0, 0, 428, 430, 3, 18, 9, 0, 429, 428,
		1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0,
		0, 0, 432, 434, 1, 0, 0, 0, 433, 413, 1, 0, 0, 0, 433, 426, 1, 0, 0, 0,
		434, 81, 1, 0, 0, 0, 435, 437, 3, 2, 1, 0, 436, 435, 1, 0, 0, 0, 436, 437,
		1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 439, 3, 0, 0, 0, 439, 440, 5, 5,
		0, 0, 440, 441, 3, 44, 22, 0, 441, 83, 1, 0, 0, 0, 442, 449, 3, 90, 45,
		0, 443, 449, 3, 94, 47, 0, 444, 449, 3, 110, 55, 0, 445, 449, 3, 114, 57,
		0, 446, 449, 3, 122, 61, 0, 447, 449, 3, 132, 66, 0, 448, 442, 1, 0, 0,
		0, 448, 443, 1, 0, 0, 0, 448, 444, 1, 0, 0, 0, 448, 445, 1, 0, 0, 0, 448,
		446, 1, 0, 0, 0, 448, 447, 1, 0, 0, 0, 449, 85, 1, 0, 0, 0, 450, 457, 3,
		96, 48, 0, 451, 457, 3, 112, 56, 0, 452, 457, 3, 116, 58, 0, 453, 457,
		3, 92, 46, 0, 454, 457, 3, 124, 62, 0, 455, 457, 3, 134, 67, 0, 456, 450,
		1, 0, 0, 0, 456, 451, 1, 0, 0, 0, 456, 452, 1, 0, 0, 0, 456, 453, 1, 0,
		0, 0, 456, 454, 1, 0, 0, 0, 456, 455, 1, 0, 0, 0, 457, 87, 1, 0, 0, 0,
		458, 459, 5, 3, 0, 0, 459, 460, 5, 4, 0, 0, 460, 89, 1, 0, 0, 0, 461, 463,
		3, 2, 1, 0, 462, 461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 464, 1, 0,
		0, 0, 464, 465, 5, 22, 0, 0, 465, 467, 3, 32, 16, 0, 466, 468, 3, 18, 9,
		0, 467, 466, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 91, 1, 0, 0, 0, 469,
		470, 5, 29, 0, 0, 470, 471, 5, 22, 0, 0, 471, 473, 3, 32, 16, 0, 472, 474,
		3, 18, 9, 0, 473, 472, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 93, 1, 0,
		0, 0, 475, 477, 3, 2, 1, 0, 476, 475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0,
		477, 478, 1, 0, 0, 0, 478, 479, 5, 23, 0, 0, 479, 481, 3, 32, 16, 0, 480,
		482, 3, 98, 49, 0, 481, 480, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 484,
		1, 0, 0, 0, 483, 485, 3, 18, 9, 0, 484, 483, 1, 0, 0, 0, 484, 485, 1, 0,
		0, 0, 485, 487, 1, 0, 0, 0, 486, 488, 3, 100, 50, 0, 487, 486, 1, 0, 0,
		0, 487, 488, 1, 0, 0, 0, 488, 95, 1, 0, 0, 0, 489, 490, 5, 29, 0, 0, 490,
		491, 5, 23, 0, 0, 491, 493, 3, 32, 16, 0, 492, 494, 3, 98, 49, 0, 493,
		492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 496, 1, 0, 0, 0, 495, 497,
		3, 18, 9, 0, 496, 495, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 498, 1, 0,
		0, 0, 498, 499, 3, 102, 51, 0, 499, 516, 1, 0, 0, 0, 500, 501, 5, 29, 0,
		0, 501, 502, 5, 23, 0, 0, 502, 504, 3, 32, 16, 0, 503, 505, 3, 98, 49,
		0, 504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506,
		508, 3, 18, 9, 0, 507, 509, 3, 88, 44, 0, 508, 507, 1, 0, 0, 0, 508, 509,
		1, 0, 0, 0, 509, 516, 1, 0, 0, 0, 510, 511, 5, 29, 0, 0, 511, 512, 5, 23,
		0, 0, 512, 513, 3, 32, 16, 0, 513, 514, 3, 98, 49, 0, 514, 516, 1, 0, 0,
		0, 515, 489, 1, 0, 0, 0, 515, 500, 1, 0, 0, 0, 515, 510, 1, 0, 0, 0, 516,
		97, 1, 0, 0, 0, 517, 518, 6, 49, -1, 0, 518, 520, 5, 25, 0, 0, 519, 521,
		5, 13, 0, 0, 520, 519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 523, 1, 0,
		0, 0, 522, 524, 3, 44, 22, 0, 523, 522, 1, 0, 0, 0, 524, 525, 1, 0, 0,
		0, 525, 523, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 532, 1, 0, 0, 0, 527,
		528, 10, 1, 0, 0, 528, 529, 5, 13, 0, 0, 529, 531, 3, 44, 22, 0, 530, 527,
		1, 0, 0, 0, 531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533, 1, 0,
		0, 0, 533, 99, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 539, 5, 3, 0, 0,
		536, 538, 3, 104, 52, 0, 537, 536, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539,
		537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 542, 1, 0, 0, 0, 541, 539,
		1, 0, 0, 0, 542, 543, 5, 4, 0, 0, 543, 101, 1, 0, 0, 0, 544, 546, 5, 3,
		0, 0, 545, 547, 3, 104, 52, 0, 546, 545, 1, 0, 0, 0, 547, 548, 1, 0, 0,
		0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550,
		551, 5, 4, 0, 0, 551, 103, 1, 0, 0, 0, 552, 554, 3, 2, 1, 0, 553, 552,
		1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 557, 3, 32,
		16, 0, 556, 558, 3, 106, 53, 0, 557, 556, 1, 0, 0, 0, 557, 558, 1, 0, 0,
		0, 558, 559, 1, 0, 0, 0, 559, 560, 5, 5, 0, 0, 560, 562, 3, 42, 21, 0,
		561, 563, 3, 18, 9, 0, 562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563,
		105, 1, 0, 0, 0, 564, 566, 5, 7, 0, 0, 565, 567, 3, 108, 54, 0, 566, 565,
		1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 566, 1, 0, 0, 0, 568, 569, 1, 0,
		0, 0, 569, 570, 1, 0, 0, 0, 570, 571, 5, 8, 0, 0, 571, 107, 1, 0, 0, 0,
		572, 574, 3, 2, 1, 0, 573, 572, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574,
		575, 1, 0, 0, 0, 575, 576, 3, 32, 16, 0, 576, 577, 5, 5, 0, 0, 577, 579,
		3, 42, 21, 0, 578, 580, 3, 40, 20, 0, 579, 578, 1, 0, 0, 0, 579, 580, 1,
		0, 0, 0, 580, 582, 1, 0, 0, 0, 581, 583, 3, 18, 9, 0, 582, 581, 1, 0, 0,
		0, 582, 583, 1, 0, 0, 0, 583, 109, 1, 0, 0, 0, 584, 586, 3, 2, 1, 0, 585,
		584, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 588,
		5, 24, 0, 0, 588, 590, 3, 32, 16, 0, 589, 591, 3, 18, 9, 0, 590, 589, 1,
		0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 593, 1, 0, 0, 0, 592, 594, 3, 100,
		50, 0, 593, 592, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 111, 1, 0, 0, 0,
		595, 596, 5, 29, 0, 0, 596, 597, 5, 24, 0, 0, 597, 599, 3, 32, 16, 0, 598,
		600, 3, 98, 49, 0, 599, 598, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 602,
		1, 0, 0, 0, 601, 603, 3, 18, 9, 0, 602, 601, 1, 0, 0, 0, 602, 603, 1, 0,
		0, 0, 603, 604, 1, 0, 0, 0, 604, 605, 3, 102, 51, 0, 605, 622, 1, 0, 0,
		0, 606, 607, 5, 29, 0, 0, 607, 608, 5, 24, 0, 0, 608, 610, 3, 32, 16, 0,
		609, 611, 3, 98, 49, 0, 610, 609, 1, 0, 0, 0, 610, 611, 1, 0, 0, 0, 611,
		612, 1, 0, 0, 0, 612, 614, 3, 18, 9, 0, 613, 615, 3, 88, 44, 0, 614, 613,
		1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 622, 1, 0, 0, 0, 616, 617, 5, 29,
		0, 0, 617, 618, 5, 24, 0, 0, 618, 619, 3, 32, 16, 0, 619, 620, 3, 98, 49,
		0, 620, 622, 1, 0, 0, 0, 621, 595, 1, 0, 0, 0, 621, 606, 1, 0, 0, 0, 621,
		616, 1, 0, 0, 0, 622, 113, 1, 0, 0, 0, 623, 625, 3, 2, 1, 0, 624, 623,
		1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 627, 5, 27,
		0, 0, 627, 629, 3, 32, 16, 0, 628, 630, 3, 18, 9, 0, 629, 628, 1, 0, 0,
		0, 629, 630, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 632, 3, 118, 59, 0,
		632, 115, 1, 0, 0, 0, 633, 634, 5, 29, 0, 0, 634, 635, 5, 27, 0, 0, 635,
		637, 3, 32, 16, 0, 636, 638, 3, 18, 9, 0, 637, 636, 1, 0, 0, 0, 637, 638,
		1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 3, 118, 59, 0, 640, 647, 1,
		0, 0, 0, 641, 642, 5, 29, 0, 0, 642, 643, 5, 27, 0, 0, 643, 644, 3, 32,
		16, 0, 644, 645, 3, 18, 9, 0, 645, 647, 1, 0, 0, 0, 646, 633, 1, 0, 0,
		0, 646, 641, 1, 0, 0, 0, 647, 117, 1, 0, 0, 0, 648, 649, 5, 10, 0, 0, 649,
		650, 3, 120, 60, 0, 650, 119, 1, 0, 0, 0, 651, 653, 6, 60, -1, 0, 652,
		654, 5, 14, 0, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 655,
		1, 0, 0, 0, 655, 656, 3, 44, 22, 0, 656, 662, 1, 0, 0, 0, 657, 658, 10,
		1, 0, 0, 658, 659, 5, 14, 0, 0, 659, 661, 3, 44, 22, 0, 660, 657, 1, 0,
		0, 0, 661, 664, 1, 0, 0, 0, 662, 660, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0,
		663, 121, 1, 0, 0, 0, 664, 662, 1, 0, 0, 0, 665, 667, 3, 2, 1, 0, 666,
		665, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 669,
		5, 26, 0, 0, 669, 671, 3, 32, 16, 0, 670, 672, 3, 18, 9, 0, 671, 670, 1,
		0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 674, 1, 0, 0, 0, 673, 675, 3, 126,
		63, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 123, 1, 0, 0, 0,
		676, 677, 5, 29, 0, 0, 677, 678, 5, 26, 0, 0, 678, 680, 3, 32, 16, 0, 679,
		681, 3, 18, 9, 0, 680, 679, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682,
		1, 0, 0, 0, 682, 683, 3, 128, 64, 0, 683, 692, 1, 0, 0, 0, 684, 685, 5,
		29, 0, 0, 685, 686, 5, 26, 0, 0, 686, 687, 3, 32, 16, 0, 687, 689, 3, 18,
		9, 0, 688, 690, 3, 88, 44, 0, 689, 688, 1, 0, 0, 0, 689, 690, 1, 0, 0,
		0, 690, 692, 1, 0, 0, 0, 691, 676, 1, 0, 0, 0, 691, 684, 1, 0, 0, 0, 692,
		125, 1, 0, 0, 0, 693, 697, 5, 3, 0, 0, 694, 696, 3, 130, 65, 0, 695, 694,
		1, 0, 0, 0, 696, 699, 1, 0, 0, 0, 697, 695, 1, 0, 0, 0, 697, 698, 1, 0,
		0, 0, 698, 700, 1, 0, 0, 0, 699, 697, 1, 0, 0, 0, 700, 701, 5, 4, 0, 0,
		701, 127, 1, 0, 0, 0, 702, 704, 5, 3, 0, 0, 703, 705, 3, 130, 65, 0, 704,
		703, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 704, 1, 0, 0, 0, 706, 707,
		1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 709, 5, 4, 0, 0, 709, 129, 1, 0,
		0, 0, 710, 712, 3, 2, 1, 0, 711, 710, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0,
		712, 713, 1, 0, 0, 0, 713, 715, 3, 4, 2, 0, 714, 716, 3, 18, 9, 0, 715,
		714, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 131, 1, 0, 0, 0, 717, 719,
		3, 2, 1, 0, 718, 717, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 1, 0,
		0, 0, 720, 721, 5, 28, 0, 0, 721, 723, 3, 32, 16, 0, 722, 724, 3, 18, 9,
		0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 726, 1, 0, 0, 0, 725,
		727, 3, 136, 68, 0, 726, 725, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727, 133,
		1, 0, 0, 0, 728, 729, 5, 29, 0, 0, 729, 730, 5, 28, 0, 0, 730, 732, 3,
		32, 16, 0, 731, 733, 3, 18, 9, 0, 732, 731, 1, 0, 0, 0, 732, 733, 1, 0,
		0, 0, 733, 734, 1, 0, 0, 0, 734, 735, 3, 138, 69, 0, 735, 744, 1, 0, 0,
		0, 736, 737, 5, 29, 0, 0, 737, 738, 5, 28, 0, 0, 738, 739, 3, 32, 16, 0,
		739, 741, 3, 18, 9, 0, 740, 742, 3, 88, 44, 0, 741, 740, 1, 0, 0, 0, 741,
		742, 1, 0, 0, 0, 742, 744, 1, 0, 0, 0, 743, 728, 1, 0, 0, 0, 743, 736,
		1, 0, 0, 0, 744, 135, 1, 0, 0, 0, 745, 749, 5, 3, 0, 0, 746, 748, 3, 108,
		54, 0, 747, 746, 1, 0, 0, 0, 748, 751, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0,
		749, 750, 1, 0, 0, 0, 750, 752, 1, 0, 0, 0, 751, 749, 1, 0, 0, 0, 752,
		753, 5, 4, 0, 0, 753, 137, 1, 0, 0, 0, 754, 756, 5, 3, 0, 0, 755, 757,
		3, 108, 54, 0, 756, 755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 756, 1,
		0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 761, 5, 4, 0,
		0, 761, 139, 1, 0, 0, 0, 762, 764, 3, 2, 1, 0, 763, 762, 1, 0, 0, 0, 763,
		764, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 766, 5, 30, 0, 0, 766, 767,
		5, 6, 0, 0, 767, 769, 3, 32, 16, 0, 768, 770, 3, 106, 53, 0, 769, 768,
		1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772, 1, 0, 0, 0, 771, 773, 5, 32,
		0, 0, 772, 771, 1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0,
		774, 775, 5, 31, 0, 0, 775, 776, 3, 144, 72, 0, 776, 141, 1, 0, 0, 0, 777,
		778, 3, 32, 16, 0, 778, 143, 1, 0, 0, 0, 779, 781, 6, 72, -1, 0, 780, 782,
		5, 14, 0, 0, 781, 780, 1, 0, 0, 0, 781, 782, 1, 0, 0, 0, 782, 783, 1, 0,
		0, 0, 783, 784, 3, 142, 71, 0, 784, 790, 1, 0, 0, 0, 785, 786, 10, 1, 0,
		0, 786, 787, 5, 14, 0, 0, 787, 789, 3, 142, 71, 0, 788, 785, 1, 0, 0, 0,
		789, 792, 1, 0, 0, 0, 790, 788, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0, 791,
		145, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 793, 795, 3, 32, 16, 0, 794, 796,
		3, 106, 53, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 797, 1,
		0, 0, 0, 797, 798, 5, 5, 0, 0, 798, 800, 3, 42, 21, 0, 799, 801, 3, 18,
		9, 0, 800, 799, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 823, 1, 0, 0, 0,
		802, 803, 3, 106, 53, 0, 803, 804, 5, 5, 0, 0, 804, 806, 3, 42, 21, 0,
		805, 807, 3, 18, 9, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807,
		823, 1, 0, 0, 0, 808, 810, 3, 32, 16, 0, 809, 811, 3, 106, 53, 0, 810,
		809, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 813, 1, 0, 0, 0, 812, 814,
		3, 18, 9, 0, 813, 812, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 823, 1, 0,
		0, 0, 815, 816, 5, 5, 0, 0, 816, 818, 3, 42, 21, 0, 817, 819, 3, 18, 9,
		0, 818, 817, 1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 823, 1, 0, 0, 0, 820,
		823, 3, 106, 53, 0, 821, 823, 3, 18, 9, 0, 822, 793, 1, 0, 0, 0, 822, 802,
		1, 0, 0, 0, 822, 808, 1, 0, 0, 0, 822, 815, 1, 0, 0, 0, 822, 820, 1, 0,
		0, 0, 822, 821, 1, 0, 0, 0, 823, 147, 1, 0, 0, 0, 824, 826, 3, 2, 1, 0,
		825, 824, 1, 0, 0, 0, 825, 826, 1, 0, 0, 0, 826, 827, 1, 0, 0, 0, 827,
		828, 5, 23, 0, 0, 828, 830, 3, 32, 16, 0, 829, 831, 3, 98, 49, 0, 830,
		829, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 833, 1, 0, 0, 0, 832, 834,
		3, 18, 9, 0, 833, 832, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 836, 1, 0,
		0, 0, 835, 837, 3, 100, 50, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0,
		0, 837, 864, 1, 0, 0, 0, 838, 840, 3, 2, 1, 0, 839, 838, 1, 0, 0, 0, 839,
		840, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 843, 3, 32, 16, 0, 842, 844,
		3, 98, 49, 0, 843, 842, 1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 846, 1,
		0, 0, 0, 845, 847, 3, 18, 9, 0, 846, 845, 1, 0, 0, 0, 846, 847, 1, 0, 0,
		0, 847, 849, 1, 0, 0, 0, 848, 850, 3, 100, 50, 0, 849, 848, 1, 0, 0, 0,
		849, 850, 1, 0, 0, 0, 850, 864, 1, 0, 0, 0, 851, 853, 3, 2, 1, 0, 852,
		851, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 855, 1, 0, 0, 0, 854, 856,
		3, 98, 49, 0, 855, 854, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 858, 1,
		0, 0, 0, 857, 859, 3, 18, 9, 0, 858, 857, 1, 0, 0, 0, 858, 859, 1, 0, 0,
		0, 859, 861, 1, 0, 0, 0, 860, 862, 3, 100, 50, 0, 861, 860, 1, 0, 0, 0,
		861, 862, 1, 0, 0, 0, 862, 864, 1, 0, 0, 0, 863, 825, 1, 0, 0, 0, 863,
		839, 1, 0, 0, 0, 863, 852, 1, 0, 0, 0, 864, 149, 1, 0, 0, 0, 865, 867,
		3, 2, 1, 0, 866, 865, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 868, 1, 0,
		0, 0, 868, 869, 5, 28, 0, 0, 869, 871, 3, 32, 16, 0, 870, 872, 3, 18, 9,
		0, 871, 870, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873,
		874, 3, 136, 68, 0, 874, 898, 1, 0, 0, 0, 875, 877, 3, 2, 1, 0, 876, 875,
		1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 3, 32,
		16, 0, 879, 881, 3, 18, 9, 0, 880, 879, 1, 0, 0, 0, 880, 881, 1, 0, 0,
		0, 881, 882, 1, 0, 0, 0, 882, 883, 3, 136, 68, 0, 883, 898, 1, 0, 0, 0,
		884, 886, 3, 2, 1, 0, 885, 884, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886,
		888, 1, 0, 0, 0, 887, 889, 3, 18, 9, 0, 888, 887, 1, 0, 0, 0, 888, 889,
		1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 898, 3, 136, 68, 0, 891, 893, 3,
		2, 1, 0, 892, 891, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 895, 1, 0, 0,
		0, 894, 896, 3, 18, 9, 0, 895, 894, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896,
		898, 1, 0, 0, 0, 897, 866, 1, 0, 0, 0, 897, 876, 1, 0, 0, 0, 897, 885,
		1, 0, 0, 0, 897, 892, 1, 0, 0, 0, 898, 151, 1, 0, 0, 0, 899, 901, 3, 2,
		1, 0, 900, 899, 1, 0, 0, 0, 900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0,
		902, 903, 3, 32, 16, 0, 903, 904, 5, 5, 0, 0, 904, 906, 3, 42, 21, 0, 905,
		907, 3, 40, 20, 0, 906, 905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 909,
		1, 0, 0, 0, 908, 910, 3, 18, 9, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0,
		0, 0, 910, 944, 1, 0, 0, 0, 911, 913, 3, 2, 1, 0, 912, 911, 1, 0, 0, 0,
		912, 913, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 916, 3, 32, 16, 0, 915,
		917, 3, 40, 20, 0, 916, 915, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 919,
		1, 0, 0, 0, 918, 920, 3, 18, 9, 0, 919, 918, 1, 0, 0, 0, 919, 920, 1, 0,
		0, 0, 920, 944, 1, 0, 0, 0, 921, 923, 3, 2, 1, 0, 922, 921, 1, 0, 0, 0,
		922, 923, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 925, 5, 5, 0, 0, 925,
		927, 3, 42, 21, 0, 926, 928, 3, 40, 20, 0, 927, 926, 1, 0, 0, 0, 927, 928,
		1, 0, 0, 0, 928, 930, 1, 0, 0, 0, 929, 931, 3, 18, 9, 0, 930, 929, 1, 0,
		0, 0, 930, 931, 1, 0, 0, 0, 931, 944, 1, 0, 0, 0, 932, 934, 3, 2, 1, 0,
		933, 932, 1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935,
		937, 3, 40, 20, 0, 936, 938, 3, 18, 9, 0, 937, 936, 1, 0, 0, 0, 937, 938,
		1, 0, 0, 0, 938, 944, 1, 0, 0, 0, 939, 941, 3, 2, 1, 0, 940, 939, 1, 0,
		0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 944, 3, 18, 9, 0,
		943, 900, 1, 0, 0, 0, 943, 912, 1, 0, 0, 0, 943, 922, 1, 0, 0, 0, 943,
		933, 1, 0, 0, 0, 943, 940, 1, 0, 0, 0, 944, 153, 1, 0, 0, 0, 945, 947,
		3, 2, 1, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 948, 1, 0,
		0, 0, 948, 949, 5, 26, 0, 0, 949, 951, 3, 32, 16, 0, 950, 952, 3, 18, 9,
		0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953,
		954, 3, 126, 63, 0, 954, 972, 1, 0, 0, 0, 955, 957, 3, 2, 1, 0, 956, 955,
		1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 958, 1, 0, 0, 0, 958, 960, 3, 32,
		16, 0, 959, 961, 3, 18, 9, 0, 960, 959, 1, 0, 0, 0, 960, 961, 1, 0, 0,
		0, 961, 962, 1, 0, 0, 0, 962, 963, 3, 126, 63, 0, 963, 972, 1, 0, 0, 0,
		964, 966, 3, 2, 1, 0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966,
		968, 1, 0, 0, 0, 967, 969, 3, 18, 9, 0, 968, 967, 1, 0, 0, 0, 968, 969,
		1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 972, 3, 126, 63, 0, 971, 946, 1,
		0, 0, 0, 971, 956, 1, 0, 0, 0, 971, 965, 1, 0, 0, 0, 972, 155, 1, 0, 0,
		0, 973, 975, 3, 2, 1, 0, 974, 973, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975,
		976, 1, 0, 0, 0, 976, 977, 5, 24, 0, 0, 977, 979, 3, 32, 16, 0, 978, 980,
		3, 18, 9, 0, 979, 978, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 1, 0,
		0, 0, 981, 982, 3, 100, 50, 0, 982, 1000, 1, 0, 0, 0, 983, 985, 3, 2, 1,
		0, 984, 983, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986,
		988, 3, 32, 16, 0, 987, 989, 3, 18, 9, 0, 988, 987, 1, 0, 0, 0, 988, 989,
		1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 991, 3, 100, 50, 0, 991, 1000, 1,
		0, 0, 0, 992, 994, 3, 2, 1, 0, 993, 992, 1, 0, 0, 0, 993, 994, 1, 0, 0,
		0, 994, 996, 1, 0, 0, 0, 995, 997, 3, 18, 9, 0, 996, 995, 1, 0, 0, 0, 996,
		997, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 1000, 3, 100, 50, 0, 999, 974,
		1, 0, 0, 0, 999, 984, 1, 0, 0, 0, 999, 993, 1, 0, 0, 0, 1000, 157, 1, 0,
		0, 0, 1001, 1003, 3, 2, 1, 0, 1002, 1001, 1, 0, 0, 0, 1002, 1003, 1, 0,
		0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1005, 5, 27, 0, 0, 1005, 1007, 3, 32,
		16, 0, 1006, 1008, 3, 18, 9, 0, 1007, 1006, 1, 0, 0, 0, 1007, 1008, 1,
		0, 0, 0, 1008, 1010, 1, 0, 0, 0, 1009, 1011, 3, 118, 59, 0, 1010, 1009,
		1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1032, 1, 0, 0, 0, 1012, 1014,
		3, 2, 1, 0, 1013, 1012, 1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 1015,
		1, 0, 0, 0, 1015, 1017, 3, 32, 16, 0, 1016, 1018, 3, 18, 9, 0, 1017, 1016,
		1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1020, 1, 0, 0, 0, 1019, 1021,
		3, 118, 59, 0, 1020, 1019, 1, 0, 0, 0, 1020, 1021, 1, 0, 0, 0, 1021, 1032,
		1, 0, 0, 0, 1022, 1024, 3, 2, 1, 0, 1023, 1022, 1, 0, 0, 0, 1023, 1024,
		1, 0, 0, 0, 1024, 1026, 1, 0, 0, 0, 1025, 1027, 3, 18, 9, 0, 1026, 1025,
		1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1029, 1, 0, 0, 0, 1028, 1030,
		3, 118, 59, 0, 1029, 1028, 1, 0, 0, 0, 1029, 1030, 1, 0, 0, 0, 1030, 1032,
		1, 0, 0, 0, 1031, 1002, 1, 0, 0, 0, 1031, 1013, 1, 0, 0, 0, 1031, 1023,
		1, 0, 0, 0, 1032, 159, 1, 0, 0, 0, 1033, 1035, 3, 2, 1, 0, 1034, 1033,
		1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1037, 1, 0, 0, 0, 1036, 1038,
		3, 32, 16, 0, 1037, 1036, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1040,
		1, 0, 0, 0, 1039, 1041, 3, 18, 9, 0, 1040, 1039, 1, 0, 0, 0, 1040, 1041,
		1, 0, 0, 0, 1041, 161, 1, 0, 0, 0, 175, 172, 181, 190, 199, 215, 220, 226,
		239, 243, 249, 259, 270, 281, 295, 300, 303, 306, 310, 316, 324, 327, 333,
		340, 343, 347, 350, 353, 361, 365, 368, 376, 385, 387, 392, 396, 399, 403,
		409, 416, 422, 431, 433, 436, 448, 456, 462, 467, 473, 476, 481, 484, 487,
		493, 496, 504, 508, 515, 520, 525, 532, 539, 548, 553, 557, 562, 568, 573,
		579, 582, 585, 590, 593, 599, 602, 610, 614, 621, 624, 629, 637, 646, 653,
		662, 666, 671, 674, 680, 689, 691, 697, 706, 711, 715, 718, 723, 726, 732,
		741, 743, 749, 758, 763, 769, 772, 781, 790, 795, 800, 806, 810, 813, 818,
		822, 825, 830, 833, 836, 839, 843, 846, 849, 852, 855, 858, 861, 863, 866,
		871, 876, 880, 885, 888, 892, 895, 897, 900, 906, 909, 912, 916, 919, 922,
		927, 930, 933, 937, 940, 943, 946, 951, 956, 960, 965, 968, 971, 974, 979,
		984, 988, 993, 996, 999, 1002, 1007, 1010, 1013, 1017, 1020, 1023, 1026,
		1029, 1031, 1034, 1037, 1040,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// GraphqlParserInit initializes any static state used to implement GraphqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGraphqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GraphqlParserInit() {
	staticData := &graphqlParserStaticData
	staticData.once.Do(graphqlParserInit)
}

// NewGraphqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGraphqlParser(input antlr.TokenStream) *GraphqlParser {
	GraphqlParserInit()
	this := new(GraphqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &graphqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "Graphql.g4"

	return this
}

// GraphqlParser tokens.
const (
	GraphqlParserEOF          = antlr.TokenEOF
	GraphqlParserT__0         = 1
	GraphqlParserT__1         = 2
	GraphqlParserT__2         = 3
	GraphqlParserT__3         = 4
	GraphqlParserT__4         = 5
	GraphqlParserT__5         = 6
	GraphqlParserT__6         = 7
	GraphqlParserT__7         = 8
	GraphqlParserT__8         = 9
	GraphqlParserT__9         = 10
	GraphqlParserT__10        = 11
	GraphqlParserT__11        = 12
	GraphqlParserT__12        = 13
	GraphqlParserT__13        = 14
	GraphqlParserBooleanValue = 15
	GraphqlParserNullValue    = 16
	GraphqlParserFRAGMENT     = 17
	GraphqlParserQUERY        = 18
	GraphqlParserMUTATION     = 19
	GraphqlParserSUBSCRIPTION = 20
	GraphqlParserSCHEMA       = 21
	GraphqlParserSCALAR       = 22
	GraphqlParserTYPE         = 23
	GraphqlParserINTERFACE    = 24
	GraphqlParserIMPLEMENTS   = 25
	GraphqlParserENUM         = 26
	GraphqlParserUNION        = 27
	GraphqlParserINPUT        = 28
	GraphqlParserEXTEND       = 29
	GraphqlParserDIRECTIVE    = 30
	GraphqlParserON_KEYWORD   = 31
	GraphqlParserREPEATABLE   = 32
	GraphqlParserNAME         = 33
	GraphqlParserIntValue     = 34
	GraphqlParserFloatValue   = 35
	GraphqlParserStringValue  = 36
	GraphqlParserIgnored      = 37
)

// GraphqlParser rules.
const (
	GraphqlParserRULE_operationType                        = 0
	GraphqlParserRULE_description                          = 1
	GraphqlParserRULE_enumValue                            = 2
	GraphqlParserRULE_arrayValue                           = 3
	GraphqlParserRULE_arrayValueWithVariable               = 4
	GraphqlParserRULE_objectValue                          = 5
	GraphqlParserRULE_objectValueWithVariable              = 6
	GraphqlParserRULE_objectField                          = 7
	GraphqlParserRULE_objectFieldWithVariable              = 8
	GraphqlParserRULE_directives                           = 9
	GraphqlParserRULE_directive                            = 10
	GraphqlParserRULE_arguments                            = 11
	GraphqlParserRULE_argument                             = 12
	GraphqlParserRULE_baseName                             = 13
	GraphqlParserRULE_fragmentName                         = 14
	GraphqlParserRULE_enumValueName                        = 15
	GraphqlParserRULE_name                                 = 16
	GraphqlParserRULE_value                                = 17
	GraphqlParserRULE_valueWithVariable                    = 18
	GraphqlParserRULE_variable                             = 19
	GraphqlParserRULE_defaultValue                         = 20
	GraphqlParserRULE_gqlType                              = 21
	GraphqlParserRULE_typeName                             = 22
	GraphqlParserRULE_listType                             = 23
	GraphqlParserRULE_nonNullType                          = 24
	GraphqlParserRULE_operationDefinition                  = 25
	GraphqlParserRULE_variableDefinitions                  = 26
	GraphqlParserRULE_variableDefinition                   = 27
	GraphqlParserRULE_selectionSet                         = 28
	GraphqlParserRULE_selection                            = 29
	GraphqlParserRULE_field                                = 30
	GraphqlParserRULE_alias                                = 31
	GraphqlParserRULE_fragmentSpread                       = 32
	GraphqlParserRULE_inlineFragment                       = 33
	GraphqlParserRULE_fragmentDefinition                   = 34
	GraphqlParserRULE_typeCondition                        = 35
	GraphqlParserRULE_document                             = 36
	GraphqlParserRULE_typeSystemDefinition                 = 37
	GraphqlParserRULE_typeSystemExtension                  = 38
	GraphqlParserRULE_schemaDefinition                     = 39
	GraphqlParserRULE_schemaExtension                      = 40
	GraphqlParserRULE_operationTypeDefinition              = 41
	GraphqlParserRULE_typeDefinition                       = 42
	GraphqlParserRULE_typeExtension                        = 43
	GraphqlParserRULE_emptyParentheses                     = 44
	GraphqlParserRULE_scalarTypeDefinition                 = 45
	GraphqlParserRULE_scalarTypeExtensionDefinition        = 46
	GraphqlParserRULE_objectTypeDefinition                 = 47
	GraphqlParserRULE_objectTypeExtensionDefinition        = 48
	GraphqlParserRULE_implementsInterfaces                 = 49
	GraphqlParserRULE_fieldsDefinition                     = 50
	GraphqlParserRULE_extensionFieldsDefinition            = 51
	GraphqlParserRULE_fieldDefinition                      = 52
	GraphqlParserRULE_argumentsDefinition                  = 53
	GraphqlParserRULE_inputValueDefinition                 = 54
	GraphqlParserRULE_interfaceTypeDefinition              = 55
	GraphqlParserRULE_interfaceTypeExtensionDefinition     = 56
	GraphqlParserRULE_unionTypeDefinition                  = 57
	GraphqlParserRULE_unionTypeExtensionDefinition         = 58
	GraphqlParserRULE_unionMembership                      = 59
	GraphqlParserRULE_unionMembers                         = 60
	GraphqlParserRULE_enumTypeDefinition                   = 61
	GraphqlParserRULE_enumTypeExtensionDefinition          = 62
	GraphqlParserRULE_enumValueDefinitions                 = 63
	GraphqlParserRULE_extensionEnumValueDefinitions        = 64
	GraphqlParserRULE_enumValueDefinition                  = 65
	GraphqlParserRULE_inputObjectTypeDefinition            = 66
	GraphqlParserRULE_inputObjectTypeExtensionDefinition   = 67
	GraphqlParserRULE_inputObjectValueDefinitions          = 68
	GraphqlParserRULE_extensionInputObjectValueDefinitions = 69
	GraphqlParserRULE_directiveDefinition                  = 70
	GraphqlParserRULE_directiveLocation                    = 71
	GraphqlParserRULE_directiveLocations                   = 72
	GraphqlParserRULE_partialFieldDefinition               = 73
	GraphqlParserRULE_partialObjectTypeDefinition          = 74
	GraphqlParserRULE_partialInputObjectTypeDefinition     = 75
	GraphqlParserRULE_partialInputValueDefinition          = 76
	GraphqlParserRULE_partialEnumTypeDefinition            = 77
	GraphqlParserRULE_partialInterfaceTypeDefinition       = 78
	GraphqlParserRULE_partialUnionTypeDefinition           = 79
	GraphqlParserRULE_partialScalarTypeDefinition          = 80
)

// IOperationTypeContext is an interface to support dynamic dispatch.
type IOperationTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSCRIPTION() antlr.TerminalNode
	MUTATION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsOperationTypeContext differentiates from other interfaces.
	IsOperationTypeContext()
}

type OperationTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationTypeContext() *OperationTypeContext {
	var p = new(OperationTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_operationType
	return p
}

func (*OperationTypeContext) IsOperationTypeContext() {}

func NewOperationTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationTypeContext {
	var p = new(OperationTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_operationType

	return p
}

func (s *OperationTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationTypeContext) SUBSCRIPTION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSUBSCRIPTION, 0)
}

func (s *OperationTypeContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserMUTATION, 0)
}

func (s *OperationTypeContext) QUERY() antlr.TerminalNode {
	return s.GetToken(GraphqlParserQUERY, 0)
}

func (s *OperationTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterOperationType(s)
	}
}

func (s *OperationTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitOperationType(s)
	}
}

func (s *OperationTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitOperationType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) OperationType() (localctx IOperationTypeContext) {
	this := p
	_ = this

	localctx = NewOperationTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GraphqlParserRULE_operationType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(162)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1835008) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringValue() antlr.TerminalNode

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) StringValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserStringValue, 0)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (s *DescriptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDescription(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Description() (localctx IDescriptionContext) {
	this := p
	_ = this

	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GraphqlParserRULE_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(164)
		p.Match(GraphqlParserStringValue)
	}

	return localctx
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumValueName() IEnumValueNameContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumValue
	return p
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) EnumValueName() IEnumValueNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueNameContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (s *EnumValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumValue() (localctx IEnumValueContext) {
	this := p
	_ = this

	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GraphqlParserRULE_enumValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(166)
		p.EnumValueName()
	}

	return localctx
}

// IArrayValueContext is an interface to support dynamic dispatch.
type IArrayValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValue() []IValueContext
	Value(i int) IValueContext

	// IsArrayValueContext differentiates from other interfaces.
	IsArrayValueContext()
}

type ArrayValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayValueContext() *ArrayValueContext {
	var p = new(ArrayValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_arrayValue
	return p
}

func (*ArrayValueContext) IsArrayValueContext() {}

func NewArrayValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayValueContext {
	var p = new(ArrayValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_arrayValue

	return p
}

func (s *ArrayValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayValueContext) AllValue() []IValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueContext); ok {
			len++
		}
	}

	tst := make([]IValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueContext); ok {
			tst[i] = t.(IValueContext)
			i++
		}
	}

	return tst
}

func (s *ArrayValueContext) Value(i int) IValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ArrayValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterArrayValue(s)
	}
}

func (s *ArrayValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitArrayValue(s)
	}
}

func (s *ArrayValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitArrayValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ArrayValue() (localctx IArrayValueContext) {
	this := p
	_ = this

	localctx = NewArrayValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GraphqlParserRULE_arrayValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(168)
		p.Match(GraphqlParserT__0)
	}
	p.SetState(172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137438920714) != 0 {
		{
			p.SetState(169)
			p.Value()
		}

		p.SetState(174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(175)
		p.Match(GraphqlParserT__1)
	}

	return localctx
}

// IArrayValueWithVariableContext is an interface to support dynamic dispatch.
type IArrayValueWithVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueWithVariable() []IValueWithVariableContext
	ValueWithVariable(i int) IValueWithVariableContext

	// IsArrayValueWithVariableContext differentiates from other interfaces.
	IsArrayValueWithVariableContext()
}

type ArrayValueWithVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayValueWithVariableContext() *ArrayValueWithVariableContext {
	var p = new(ArrayValueWithVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_arrayValueWithVariable
	return p
}

func (*ArrayValueWithVariableContext) IsArrayValueWithVariableContext() {}

func NewArrayValueWithVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayValueWithVariableContext {
	var p = new(ArrayValueWithVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_arrayValueWithVariable

	return p
}

func (s *ArrayValueWithVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayValueWithVariableContext) AllValueWithVariable() []IValueWithVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueWithVariableContext); ok {
			len++
		}
	}

	tst := make([]IValueWithVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueWithVariableContext); ok {
			tst[i] = t.(IValueWithVariableContext)
			i++
		}
	}

	return tst
}

func (s *ArrayValueWithVariableContext) ValueWithVariable(i int) IValueWithVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueWithVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueWithVariableContext)
}

func (s *ArrayValueWithVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayValueWithVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayValueWithVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterArrayValueWithVariable(s)
	}
}

func (s *ArrayValueWithVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitArrayValueWithVariable(s)
	}
}

func (s *ArrayValueWithVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitArrayValueWithVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ArrayValueWithVariable() (localctx IArrayValueWithVariableContext) {
	this := p
	_ = this

	localctx = NewArrayValueWithVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GraphqlParserRULE_arrayValueWithVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(177)
		p.Match(GraphqlParserT__0)
	}
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137438921226) != 0 {
		{
			p.SetState(178)
			p.ValueWithVariable()
		}

		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(184)
		p.Match(GraphqlParserT__1)
	}

	return localctx
}

// IObjectValueContext is an interface to support dynamic dispatch.
type IObjectValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext

	// IsObjectValueContext differentiates from other interfaces.
	IsObjectValueContext()
}

type ObjectValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectValueContext() *ObjectValueContext {
	var p = new(ObjectValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectValue
	return p
}

func (*ObjectValueContext) IsObjectValueContext() {}

func NewObjectValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectValueContext {
	var p = new(ObjectValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectValue

	return p
}

func (s *ObjectValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectValueContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectValueContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectValue(s)
	}
}

func (s *ObjectValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectValue(s)
	}
}

func (s *ObjectValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectValue() (localctx IObjectValueContext) {
	this := p
	_ = this

	localctx = NewObjectValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GraphqlParserRULE_objectValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179836416) != 0 {
		{
			p.SetState(187)
			p.ObjectField()
		}

		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(193)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IObjectValueWithVariableContext is an interface to support dynamic dispatch.
type IObjectValueWithVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectFieldWithVariable() []IObjectFieldWithVariableContext
	ObjectFieldWithVariable(i int) IObjectFieldWithVariableContext

	// IsObjectValueWithVariableContext differentiates from other interfaces.
	IsObjectValueWithVariableContext()
}

type ObjectValueWithVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectValueWithVariableContext() *ObjectValueWithVariableContext {
	var p = new(ObjectValueWithVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectValueWithVariable
	return p
}

func (*ObjectValueWithVariableContext) IsObjectValueWithVariableContext() {}

func NewObjectValueWithVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectValueWithVariableContext {
	var p = new(ObjectValueWithVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectValueWithVariable

	return p
}

func (s *ObjectValueWithVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectValueWithVariableContext) AllObjectFieldWithVariable() []IObjectFieldWithVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldWithVariableContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldWithVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldWithVariableContext); ok {
			tst[i] = t.(IObjectFieldWithVariableContext)
			i++
		}
	}

	return tst
}

func (s *ObjectValueWithVariableContext) ObjectFieldWithVariable(i int) IObjectFieldWithVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldWithVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldWithVariableContext)
}

func (s *ObjectValueWithVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectValueWithVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectValueWithVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectValueWithVariable(s)
	}
}

func (s *ObjectValueWithVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectValueWithVariable(s)
	}
}

func (s *ObjectValueWithVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectValueWithVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectValueWithVariable() (localctx IObjectValueWithVariableContext) {
	this := p
	_ = this

	localctx = NewObjectValueWithVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GraphqlParserRULE_objectValueWithVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(195)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(199)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179836416) != 0 {
		{
			p.SetState(196)
			p.ObjectFieldWithVariable()
		}

		p.SetState(201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(202)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	Value() IValueContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectField
	return p
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ObjectFieldContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectField() (localctx IObjectFieldContext) {
	this := p
	_ = this

	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GraphqlParserRULE_objectField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(204)
		p.Name()
	}
	{
		p.SetState(205)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(206)
		p.Value()
	}

	return localctx
}

// IObjectFieldWithVariableContext is an interface to support dynamic dispatch.
type IObjectFieldWithVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	ValueWithVariable() IValueWithVariableContext

	// IsObjectFieldWithVariableContext differentiates from other interfaces.
	IsObjectFieldWithVariableContext()
}

type ObjectFieldWithVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldWithVariableContext() *ObjectFieldWithVariableContext {
	var p = new(ObjectFieldWithVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectFieldWithVariable
	return p
}

func (*ObjectFieldWithVariableContext) IsObjectFieldWithVariableContext() {}

func NewObjectFieldWithVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldWithVariableContext {
	var p = new(ObjectFieldWithVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectFieldWithVariable

	return p
}

func (s *ObjectFieldWithVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldWithVariableContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ObjectFieldWithVariableContext) ValueWithVariable() IValueWithVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueWithVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueWithVariableContext)
}

func (s *ObjectFieldWithVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldWithVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldWithVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectFieldWithVariable(s)
	}
}

func (s *ObjectFieldWithVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectFieldWithVariable(s)
	}
}

func (s *ObjectFieldWithVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectFieldWithVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectFieldWithVariable() (localctx IObjectFieldWithVariableContext) {
	this := p
	_ = this

	localctx = NewObjectFieldWithVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GraphqlParserRULE_objectFieldWithVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(208)
		p.Name()
	}
	{
		p.SetState(209)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(210)
		p.ValueWithVariable()
	}

	return localctx
}

// IDirectivesContext is an interface to support dynamic dispatch.
type IDirectivesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDirective() []IDirectiveContext
	Directive(i int) IDirectiveContext

	// IsDirectivesContext differentiates from other interfaces.
	IsDirectivesContext()
}

type DirectivesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectivesContext() *DirectivesContext {
	var p = new(DirectivesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_directives
	return p
}

func (*DirectivesContext) IsDirectivesContext() {}

func NewDirectivesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectivesContext {
	var p = new(DirectivesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_directives

	return p
}

func (s *DirectivesContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectivesContext) AllDirective() []IDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectiveContext); ok {
			tst[i] = t.(IDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *DirectivesContext) Directive(i int) IDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveContext)
}

func (s *DirectivesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectivesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectivesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDirectives(s)
	}
}

func (s *DirectivesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDirectives(s)
	}
}

func (s *DirectivesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDirectives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Directives() (localctx IDirectivesContext) {
	this := p
	_ = this

	localctx = NewDirectivesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GraphqlParserRULE_directives)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(212)
				p.Directive()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IDirectiveContext is an interface to support dynamic dispatch.
type IDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	Arguments() IArgumentsContext

	// IsDirectiveContext differentiates from other interfaces.
	IsDirectiveContext()
}

type DirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveContext() *DirectiveContext {
	var p = new(DirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_directive
	return p
}

func (*DirectiveContext) IsDirectiveContext() {}

func NewDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveContext {
	var p = new(DirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_directive

	return p
}

func (s *DirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *DirectiveContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *DirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDirective(s)
	}
}

func (s *DirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDirective(s)
	}
}

func (s *DirectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDirective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Directive() (localctx IDirectiveContext) {
	this := p
	_ = this

	localctx = NewDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GraphqlParserRULE_directive)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(217)
		p.Match(GraphqlParserT__5)
	}
	{
		p.SetState(218)
		p.Name()
	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__6 {
		{
			p.SetState(219)
			p.Arguments()
		}

	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GraphqlParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(GraphqlParserT__6)
	}
	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179836416) != 0) {
		{
			p.SetState(223)
			p.Argument()
		}

		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(228)
		p.Match(GraphqlParserT__7)
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	ValueWithVariable() IValueWithVariableContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ArgumentContext) ValueWithVariable() IValueWithVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueWithVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueWithVariableContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Argument() (localctx IArgumentContext) {
	this := p
	_ = this

	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GraphqlParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Name()
	}
	{
		p.SetState(231)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(232)
		p.ValueWithVariable()
	}

	return localctx
}

// IBaseNameContext is an interface to support dynamic dispatch.
type IBaseNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	FRAGMENT() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	MUTATION() antlr.TerminalNode
	SUBSCRIPTION() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SCALAR() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	UNION() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	DIRECTIVE() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode

	// IsBaseNameContext differentiates from other interfaces.
	IsBaseNameContext()
}

type BaseNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseNameContext() *BaseNameContext {
	var p = new(BaseNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_baseName
	return p
}

func (*BaseNameContext) IsBaseNameContext() {}

func NewBaseNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseNameContext {
	var p = new(BaseNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_baseName

	return p
}

func (s *BaseNameContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(GraphqlParserNAME, 0)
}

func (s *BaseNameContext) FRAGMENT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserFRAGMENT, 0)
}

func (s *BaseNameContext) QUERY() antlr.TerminalNode {
	return s.GetToken(GraphqlParserQUERY, 0)
}

func (s *BaseNameContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserMUTATION, 0)
}

func (s *BaseNameContext) SUBSCRIPTION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSUBSCRIPTION, 0)
}

func (s *BaseNameContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCHEMA, 0)
}

func (s *BaseNameContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCALAR, 0)
}

func (s *BaseNameContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserTYPE, 0)
}

func (s *BaseNameContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINTERFACE, 0)
}

func (s *BaseNameContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GraphqlParserIMPLEMENTS, 0)
}

func (s *BaseNameContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GraphqlParserENUM, 0)
}

func (s *BaseNameContext) UNION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserUNION, 0)
}

func (s *BaseNameContext) INPUT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINPUT, 0)
}

func (s *BaseNameContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *BaseNameContext) DIRECTIVE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserDIRECTIVE, 0)
}

func (s *BaseNameContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserREPEATABLE, 0)
}

func (s *BaseNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterBaseName(s)
	}
}

func (s *BaseNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitBaseName(s)
	}
}

func (s *BaseNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitBaseName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) BaseName() (localctx IBaseNameContext) {
	this := p
	_ = this

	localctx = NewBaseNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GraphqlParserRULE_baseName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(234)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15032254464) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFragmentNameContext is an interface to support dynamic dispatch.
type IFragmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseName() IBaseNameContext
	BooleanValue() antlr.TerminalNode
	NullValue() antlr.TerminalNode

	// IsFragmentNameContext differentiates from other interfaces.
	IsFragmentNameContext()
}

type FragmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFragmentNameContext() *FragmentNameContext {
	var p = new(FragmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_fragmentName
	return p
}

func (*FragmentNameContext) IsFragmentNameContext() {}

func NewFragmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FragmentNameContext {
	var p = new(FragmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_fragmentName

	return p
}

func (s *FragmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FragmentNameContext) BaseName() IBaseNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseNameContext)
}

func (s *FragmentNameContext) BooleanValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserBooleanValue, 0)
}

func (s *FragmentNameContext) NullValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserNullValue, 0)
}

func (s *FragmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FragmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FragmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterFragmentName(s)
	}
}

func (s *FragmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitFragmentName(s)
	}
}

func (s *FragmentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitFragmentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) FragmentName() (localctx IFragmentNameContext) {
	this := p
	_ = this

	localctx = NewFragmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GraphqlParserRULE_fragmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(239)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(236)
			p.BaseName()
		}

	case GraphqlParserBooleanValue:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(237)
			p.Match(GraphqlParserBooleanValue)
		}

	case GraphqlParserNullValue:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(238)
			p.Match(GraphqlParserNullValue)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumValueNameContext is an interface to support dynamic dispatch.
type IEnumValueNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseName() IBaseNameContext
	ON_KEYWORD() antlr.TerminalNode

	// IsEnumValueNameContext differentiates from other interfaces.
	IsEnumValueNameContext()
}

type EnumValueNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueNameContext() *EnumValueNameContext {
	var p = new(EnumValueNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumValueName
	return p
}

func (*EnumValueNameContext) IsEnumValueNameContext() {}

func NewEnumValueNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueNameContext {
	var p = new(EnumValueNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumValueName

	return p
}

func (s *EnumValueNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueNameContext) BaseName() IBaseNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseNameContext)
}

func (s *EnumValueNameContext) ON_KEYWORD() antlr.TerminalNode {
	return s.GetToken(GraphqlParserON_KEYWORD, 0)
}

func (s *EnumValueNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumValueName(s)
	}
}

func (s *EnumValueNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumValueName(s)
	}
}

func (s *EnumValueNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumValueName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumValueName() (localctx IEnumValueNameContext) {
	this := p
	_ = this

	localctx = NewEnumValueNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GraphqlParserRULE_enumValueName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(243)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(241)
			p.BaseName()
		}

	case GraphqlParserON_KEYWORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(242)
			p.Match(GraphqlParserON_KEYWORD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseName() IBaseNameContext
	BooleanValue() antlr.TerminalNode
	NullValue() antlr.TerminalNode
	ON_KEYWORD() antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) BaseName() IBaseNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseNameContext)
}

func (s *NameContext) BooleanValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserBooleanValue, 0)
}

func (s *NameContext) NullValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserNullValue, 0)
}

func (s *NameContext) ON_KEYWORD() antlr.TerminalNode {
	return s.GetToken(GraphqlParserON_KEYWORD, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GraphqlParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(249)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(245)
			p.BaseName()
		}

	case GraphqlParserBooleanValue:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(246)
			p.Match(GraphqlParserBooleanValue)
		}

	case GraphqlParserNullValue:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(247)
			p.Match(GraphqlParserNullValue)
		}

	case GraphqlParserON_KEYWORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(248)
			p.Match(GraphqlParserON_KEYWORD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringValue() antlr.TerminalNode
	IntValue() antlr.TerminalNode
	FloatValue() antlr.TerminalNode
	BooleanValue() antlr.TerminalNode
	NullValue() antlr.TerminalNode
	EnumValue() IEnumValueContext
	ArrayValue() IArrayValueContext
	ObjectValue() IObjectValueContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) StringValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserStringValue, 0)
}

func (s *ValueContext) IntValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserIntValue, 0)
}

func (s *ValueContext) FloatValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserFloatValue, 0)
}

func (s *ValueContext) BooleanValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserBooleanValue, 0)
}

func (s *ValueContext) NullValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserNullValue, 0)
}

func (s *ValueContext) EnumValue() IEnumValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *ValueContext) ArrayValue() IArrayValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayValueContext)
}

func (s *ValueContext) ObjectValue() IObjectValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectValueContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitValue(s)
	}
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Value() (localctx IValueContext) {
	this := p
	_ = this

	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GraphqlParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(259)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserStringValue:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(251)
			p.Match(GraphqlParserStringValue)
		}

	case GraphqlParserIntValue:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.Match(GraphqlParserIntValue)
		}

	case GraphqlParserFloatValue:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(253)
			p.Match(GraphqlParserFloatValue)
		}

	case GraphqlParserBooleanValue:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(254)
			p.Match(GraphqlParserBooleanValue)
		}

	case GraphqlParserNullValue:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(255)
			p.Match(GraphqlParserNullValue)
		}

	case GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserON_KEYWORD, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(256)
			p.EnumValue()
		}

	case GraphqlParserT__0:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(257)
			p.ArrayValue()
		}

	case GraphqlParserT__2:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(258)
			p.ObjectValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValueWithVariableContext is an interface to support dynamic dispatch.
type IValueWithVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable() IVariableContext
	StringValue() antlr.TerminalNode
	IntValue() antlr.TerminalNode
	FloatValue() antlr.TerminalNode
	BooleanValue() antlr.TerminalNode
	NullValue() antlr.TerminalNode
	EnumValue() IEnumValueContext
	ArrayValueWithVariable() IArrayValueWithVariableContext
	ObjectValueWithVariable() IObjectValueWithVariableContext

	// IsValueWithVariableContext differentiates from other interfaces.
	IsValueWithVariableContext()
}

type ValueWithVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueWithVariableContext() *ValueWithVariableContext {
	var p = new(ValueWithVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_valueWithVariable
	return p
}

func (*ValueWithVariableContext) IsValueWithVariableContext() {}

func NewValueWithVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueWithVariableContext {
	var p = new(ValueWithVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_valueWithVariable

	return p
}

func (s *ValueWithVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueWithVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ValueWithVariableContext) StringValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserStringValue, 0)
}

func (s *ValueWithVariableContext) IntValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserIntValue, 0)
}

func (s *ValueWithVariableContext) FloatValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserFloatValue, 0)
}

func (s *ValueWithVariableContext) BooleanValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserBooleanValue, 0)
}

func (s *ValueWithVariableContext) NullValue() antlr.TerminalNode {
	return s.GetToken(GraphqlParserNullValue, 0)
}

func (s *ValueWithVariableContext) EnumValue() IEnumValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *ValueWithVariableContext) ArrayValueWithVariable() IArrayValueWithVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayValueWithVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayValueWithVariableContext)
}

func (s *ValueWithVariableContext) ObjectValueWithVariable() IObjectValueWithVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectValueWithVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectValueWithVariableContext)
}

func (s *ValueWithVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueWithVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueWithVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterValueWithVariable(s)
	}
}

func (s *ValueWithVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitValueWithVariable(s)
	}
}

func (s *ValueWithVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitValueWithVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ValueWithVariable() (localctx IValueWithVariableContext) {
	this := p
	_ = this

	localctx = NewValueWithVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GraphqlParserRULE_valueWithVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(270)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserT__8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.Variable()
		}

	case GraphqlParserStringValue:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(262)
			p.Match(GraphqlParserStringValue)
		}

	case GraphqlParserIntValue:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(263)
			p.Match(GraphqlParserIntValue)
		}

	case GraphqlParserFloatValue:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(264)
			p.Match(GraphqlParserFloatValue)
		}

	case GraphqlParserBooleanValue:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(265)
			p.Match(GraphqlParserBooleanValue)
		}

	case GraphqlParserNullValue:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(266)
			p.Match(GraphqlParserNullValue)
		}

	case GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserON_KEYWORD, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(267)
			p.EnumValue()
		}

	case GraphqlParserT__0:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(268)
			p.ArrayValueWithVariable()
		}

	case GraphqlParserT__2:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(269)
			p.ObjectValueWithVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GraphqlParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Match(GraphqlParserT__8)
	}
	{
		p.SetState(273)
		p.Name()
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Value() IValueContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, GraphqlParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(GraphqlParserT__9)
	}
	{
		p.SetState(276)
		p.Value()
	}

	return localctx
}

// IGqlTypeContext is an interface to support dynamic dispatch.
type IGqlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ListType() IListTypeContext
	NonNullType() INonNullTypeContext

	// IsGqlTypeContext differentiates from other interfaces.
	IsGqlTypeContext()
}

type GqlTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGqlTypeContext() *GqlTypeContext {
	var p = new(GqlTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_gqlType
	return p
}

func (*GqlTypeContext) IsGqlTypeContext() {}

func NewGqlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GqlTypeContext {
	var p = new(GqlTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_gqlType

	return p
}

func (s *GqlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GqlTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *GqlTypeContext) ListType() IListTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListTypeContext)
}

func (s *GqlTypeContext) NonNullType() INonNullTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonNullTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonNullTypeContext)
}

func (s *GqlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GqlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GqlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterGqlType(s)
	}
}

func (s *GqlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitGqlType(s)
	}
}

func (s *GqlTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitGqlType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) GqlType() (localctx IGqlTypeContext) {
	this := p
	_ = this

	localctx = NewGqlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GraphqlParserRULE_gqlType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(278)
			p.TypeName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(279)
			p.ListType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(280)
			p.NonNullType()
		}

	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GraphqlParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Name()
	}

	return localctx
}

// IListTypeContext is an interface to support dynamic dispatch.
type IListTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GqlType() IGqlTypeContext

	// IsListTypeContext differentiates from other interfaces.
	IsListTypeContext()
}

type ListTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListTypeContext() *ListTypeContext {
	var p = new(ListTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_listType
	return p
}

func (*ListTypeContext) IsListTypeContext() {}

func NewListTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListTypeContext {
	var p = new(ListTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_listType

	return p
}

func (s *ListTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ListTypeContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *ListTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterListType(s)
	}
}

func (s *ListTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitListType(s)
	}
}

func (s *ListTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitListType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ListType() (localctx IListTypeContext) {
	this := p
	_ = this

	localctx = NewListTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, GraphqlParserRULE_listType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.Match(GraphqlParserT__0)
	}
	{
		p.SetState(286)
		p.GqlType()
	}
	{
		p.SetState(287)
		p.Match(GraphqlParserT__1)
	}

	return localctx
}

// INonNullTypeContext is an interface to support dynamic dispatch.
type INonNullTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ListType() IListTypeContext

	// IsNonNullTypeContext differentiates from other interfaces.
	IsNonNullTypeContext()
}

type NonNullTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonNullTypeContext() *NonNullTypeContext {
	var p = new(NonNullTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_nonNullType
	return p
}

func (*NonNullTypeContext) IsNonNullTypeContext() {}

func NewNonNullTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonNullTypeContext {
	var p = new(NonNullTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_nonNullType

	return p
}

func (s *NonNullTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NonNullTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *NonNullTypeContext) ListType() IListTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListTypeContext)
}

func (s *NonNullTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonNullTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonNullTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterNonNullType(s)
	}
}

func (s *NonNullTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitNonNullType(s)
	}
}

func (s *NonNullTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitNonNullType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) NonNullType() (localctx INonNullTypeContext) {
	this := p
	_ = this

	localctx = NewNonNullTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, GraphqlParserRULE_nonNullType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(295)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserBooleanValue, GraphqlParserNullValue, GraphqlParserFRAGMENT, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION, GraphqlParserSCHEMA, GraphqlParserSCALAR, GraphqlParserTYPE, GraphqlParserINTERFACE, GraphqlParserIMPLEMENTS, GraphqlParserENUM, GraphqlParserUNION, GraphqlParserINPUT, GraphqlParserEXTEND, GraphqlParserDIRECTIVE, GraphqlParserON_KEYWORD, GraphqlParserREPEATABLE, GraphqlParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(289)
			p.TypeName()
		}
		{
			p.SetState(290)
			p.Match(GraphqlParserT__10)
		}

	case GraphqlParserT__0:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(292)
			p.ListType()
		}
		{
			p.SetState(293)
			p.Match(GraphqlParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperationDefinitionContext is an interface to support dynamic dispatch.
type IOperationDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectionSet() ISelectionSetContext
	OperationType() IOperationTypeContext
	Name() INameContext
	VariableDefinitions() IVariableDefinitionsContext
	Directives() IDirectivesContext

	// IsOperationDefinitionContext differentiates from other interfaces.
	IsOperationDefinitionContext()
}

type OperationDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationDefinitionContext() *OperationDefinitionContext {
	var p = new(OperationDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_operationDefinition
	return p
}

func (*OperationDefinitionContext) IsOperationDefinitionContext() {}

func NewOperationDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationDefinitionContext {
	var p = new(OperationDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_operationDefinition

	return p
}

func (s *OperationDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationDefinitionContext) SelectionSet() ISelectionSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionSetContext)
}

func (s *OperationDefinitionContext) OperationType() IOperationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationTypeContext)
}

func (s *OperationDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *OperationDefinitionContext) VariableDefinitions() IVariableDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDefinitionsContext)
}

func (s *OperationDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *OperationDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterOperationDefinition(s)
	}
}

func (s *OperationDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitOperationDefinition(s)
	}
}

func (s *OperationDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitOperationDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) OperationDefinition() (localctx IOperationDefinitionContext) {
	this := p
	_ = this

	localctx = NewOperationDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, GraphqlParserRULE_operationDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(310)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GraphqlParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(297)
			p.SelectionSet()
		}

	case GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(298)
			p.OperationType()
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179836416) != 0 {
			{
				p.SetState(299)
				p.Name()
			}

		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__6 {
			{
				p.SetState(302)
				p.VariableDefinitions()
			}

		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(305)
				p.Directives()
			}

		}
		{
			p.SetState(308)
			p.SelectionSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableDefinitionsContext is an interface to support dynamic dispatch.
type IVariableDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDefinition() []IVariableDefinitionContext
	VariableDefinition(i int) IVariableDefinitionContext

	// IsVariableDefinitionsContext differentiates from other interfaces.
	IsVariableDefinitionsContext()
}

type VariableDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDefinitionsContext() *VariableDefinitionsContext {
	var p = new(VariableDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_variableDefinitions
	return p
}

func (*VariableDefinitionsContext) IsVariableDefinitionsContext() {}

func NewVariableDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDefinitionsContext {
	var p = new(VariableDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_variableDefinitions

	return p
}

func (s *VariableDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDefinitionsContext) AllVariableDefinition() []IVariableDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IVariableDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDefinitionContext); ok {
			tst[i] = t.(IVariableDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDefinitionsContext) VariableDefinition(i int) IVariableDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDefinitionContext)
}

func (s *VariableDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterVariableDefinitions(s)
	}
}

func (s *VariableDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitVariableDefinitions(s)
	}
}

func (s *VariableDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitVariableDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) VariableDefinitions() (localctx IVariableDefinitionsContext) {
	this := p
	_ = this

	localctx = NewVariableDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GraphqlParserRULE_variableDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.Match(GraphqlParserT__6)
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GraphqlParserT__8 {
		{
			p.SetState(313)
			p.VariableDefinition()
		}

		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(318)
		p.Match(GraphqlParserT__7)
	}

	return localctx
}

// IVariableDefinitionContext is an interface to support dynamic dispatch.
type IVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable() IVariableContext
	GqlType() IGqlTypeContext
	DefaultValue() IDefaultValueContext
	Directives() IDirectivesContext

	// IsVariableDefinitionContext differentiates from other interfaces.
	IsVariableDefinitionContext()
}

type VariableDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDefinitionContext() *VariableDefinitionContext {
	var p = new(VariableDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_variableDefinition
	return p
}

func (*VariableDefinitionContext) IsVariableDefinitionContext() {}

func NewVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDefinitionContext {
	var p = new(VariableDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_variableDefinition

	return p
}

func (s *VariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDefinitionContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *VariableDefinitionContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *VariableDefinitionContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *VariableDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *VariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterVariableDefinition(s)
	}
}

func (s *VariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitVariableDefinition(s)
	}
}

func (s *VariableDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitVariableDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) VariableDefinition() (localctx IVariableDefinitionContext) {
	this := p
	_ = this

	localctx = NewVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GraphqlParserRULE_variableDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Variable()
	}
	{
		p.SetState(321)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(322)
		p.GqlType()
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__9 {
		{
			p.SetState(323)
			p.DefaultValue()
		}

	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(326)
			p.Directives()
		}

	}

	return localctx
}

// ISelectionSetContext is an interface to support dynamic dispatch.
type ISelectionSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelection() []ISelectionContext
	Selection(i int) ISelectionContext

	// IsSelectionSetContext differentiates from other interfaces.
	IsSelectionSetContext()
}

type SelectionSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectionSetContext() *SelectionSetContext {
	var p = new(SelectionSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_selectionSet
	return p
}

func (*SelectionSetContext) IsSelectionSetContext() {}

func NewSelectionSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionSetContext {
	var p = new(SelectionSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_selectionSet

	return p
}

func (s *SelectionSetContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionSetContext) AllSelection() []ISelectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectionContext); ok {
			len++
		}
	}

	tst := make([]ISelectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectionContext); ok {
			tst[i] = t.(ISelectionContext)
			i++
		}
	}

	return tst
}

func (s *SelectionSetContext) Selection(i int) ISelectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionContext)
}

func (s *SelectionSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterSelectionSet(s)
	}
}

func (s *SelectionSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitSelectionSet(s)
	}
}

func (s *SelectionSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitSelectionSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) SelectionSet() (localctx ISelectionSetContext) {
	this := p
	_ = this

	localctx = NewSelectionSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GraphqlParserRULE_selectionSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179840512) != 0) {
		{
			p.SetState(330)
			p.Selection()
		}

		p.SetState(333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(335)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// ISelectionContext is an interface to support dynamic dispatch.
type ISelectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Field() IFieldContext
	FragmentSpread() IFragmentSpreadContext
	InlineFragment() IInlineFragmentContext

	// IsSelectionContext differentiates from other interfaces.
	IsSelectionContext()
}

type SelectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectionContext() *SelectionContext {
	var p = new(SelectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_selection
	return p
}

func (*SelectionContext) IsSelectionContext() {}

func NewSelectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionContext {
	var p = new(SelectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_selection

	return p
}

func (s *SelectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionContext) Field() IFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *SelectionContext) FragmentSpread() IFragmentSpreadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFragmentSpreadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFragmentSpreadContext)
}

func (s *SelectionContext) InlineFragment() IInlineFragmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFragmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFragmentContext)
}

func (s *SelectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterSelection(s)
	}
}

func (s *SelectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitSelection(s)
	}
}

func (s *SelectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitSelection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Selection() (localctx ISelectionContext) {
	this := p
	_ = this

	localctx = NewSelectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GraphqlParserRULE_selection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(337)
			p.Field()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(338)
			p.FragmentSpread()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(339)
			p.InlineFragment()
		}

	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	Alias() IAliasContext
	Arguments() IArgumentsContext
	Directives() IDirectivesContext
	SelectionSet() ISelectionSetContext

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FieldContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *FieldContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *FieldContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *FieldContext) SelectionSet() ISelectionSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionSetContext)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitField(s)
	}
}

func (s *FieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Field() (localctx IFieldContext) {
	this := p
	_ = this

	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GraphqlParserRULE_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(343)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(342)
			p.Alias()
		}

	}
	{
		p.SetState(345)
		p.Name()
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__6 {
		{
			p.SetState(346)
			p.Arguments()
		}

	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(349)
			p.Directives()
		}

	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__2 {
		{
			p.SetState(352)
			p.SelectionSet()
		}

	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Alias() (localctx IAliasContext) {
	this := p
	_ = this

	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GraphqlParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Name()
	}
	{
		p.SetState(356)
		p.Match(GraphqlParserT__4)
	}

	return localctx
}

// IFragmentSpreadContext is an interface to support dynamic dispatch.
type IFragmentSpreadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FragmentName() IFragmentNameContext
	Directives() IDirectivesContext

	// IsFragmentSpreadContext differentiates from other interfaces.
	IsFragmentSpreadContext()
}

type FragmentSpreadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFragmentSpreadContext() *FragmentSpreadContext {
	var p = new(FragmentSpreadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_fragmentSpread
	return p
}

func (*FragmentSpreadContext) IsFragmentSpreadContext() {}

func NewFragmentSpreadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FragmentSpreadContext {
	var p = new(FragmentSpreadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_fragmentSpread

	return p
}

func (s *FragmentSpreadContext) GetParser() antlr.Parser { return s.parser }

func (s *FragmentSpreadContext) FragmentName() IFragmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFragmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFragmentNameContext)
}

func (s *FragmentSpreadContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *FragmentSpreadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FragmentSpreadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FragmentSpreadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterFragmentSpread(s)
	}
}

func (s *FragmentSpreadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitFragmentSpread(s)
	}
}

func (s *FragmentSpreadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitFragmentSpread(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) FragmentSpread() (localctx IFragmentSpreadContext) {
	this := p
	_ = this

	localctx = NewFragmentSpreadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GraphqlParserRULE_fragmentSpread)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		p.Match(GraphqlParserT__11)
	}
	{
		p.SetState(359)
		p.FragmentName()
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(360)
			p.Directives()
		}

	}

	return localctx
}

// IInlineFragmentContext is an interface to support dynamic dispatch.
type IInlineFragmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectionSet() ISelectionSetContext
	TypeCondition() ITypeConditionContext
	Directives() IDirectivesContext

	// IsInlineFragmentContext differentiates from other interfaces.
	IsInlineFragmentContext()
}

type InlineFragmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFragmentContext() *InlineFragmentContext {
	var p = new(InlineFragmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_inlineFragment
	return p
}

func (*InlineFragmentContext) IsInlineFragmentContext() {}

func NewInlineFragmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFragmentContext {
	var p = new(InlineFragmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_inlineFragment

	return p
}

func (s *InlineFragmentContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFragmentContext) SelectionSet() ISelectionSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionSetContext)
}

func (s *InlineFragmentContext) TypeCondition() ITypeConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConditionContext)
}

func (s *InlineFragmentContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InlineFragmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFragmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFragmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInlineFragment(s)
	}
}

func (s *InlineFragmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInlineFragment(s)
	}
}

func (s *InlineFragmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInlineFragment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InlineFragment() (localctx IInlineFragmentContext) {
	this := p
	_ = this

	localctx = NewInlineFragmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GraphqlParserRULE_inlineFragment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Match(GraphqlParserT__11)
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserON_KEYWORD {
		{
			p.SetState(364)
			p.TypeCondition()
		}

	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(367)
			p.Directives()
		}

	}
	{
		p.SetState(370)
		p.SelectionSet()
	}

	return localctx
}

// IFragmentDefinitionContext is an interface to support dynamic dispatch.
type IFragmentDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FRAGMENT() antlr.TerminalNode
	FragmentName() IFragmentNameContext
	TypeCondition() ITypeConditionContext
	SelectionSet() ISelectionSetContext
	Directives() IDirectivesContext

	// IsFragmentDefinitionContext differentiates from other interfaces.
	IsFragmentDefinitionContext()
}

type FragmentDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFragmentDefinitionContext() *FragmentDefinitionContext {
	var p = new(FragmentDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_fragmentDefinition
	return p
}

func (*FragmentDefinitionContext) IsFragmentDefinitionContext() {}

func NewFragmentDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FragmentDefinitionContext {
	var p = new(FragmentDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_fragmentDefinition

	return p
}

func (s *FragmentDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FragmentDefinitionContext) FRAGMENT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserFRAGMENT, 0)
}

func (s *FragmentDefinitionContext) FragmentName() IFragmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFragmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFragmentNameContext)
}

func (s *FragmentDefinitionContext) TypeCondition() ITypeConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConditionContext)
}

func (s *FragmentDefinitionContext) SelectionSet() ISelectionSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionSetContext)
}

func (s *FragmentDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *FragmentDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FragmentDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FragmentDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterFragmentDefinition(s)
	}
}

func (s *FragmentDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitFragmentDefinition(s)
	}
}

func (s *FragmentDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitFragmentDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) FragmentDefinition() (localctx IFragmentDefinitionContext) {
	this := p
	_ = this

	localctx = NewFragmentDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GraphqlParserRULE_fragmentDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(GraphqlParserFRAGMENT)
	}
	{
		p.SetState(373)
		p.FragmentName()
	}
	{
		p.SetState(374)
		p.TypeCondition()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(375)
			p.Directives()
		}

	}
	{
		p.SetState(378)
		p.SelectionSet()
	}

	return localctx
}

// ITypeConditionContext is an interface to support dynamic dispatch.
type ITypeConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_KEYWORD() antlr.TerminalNode
	TypeName() ITypeNameContext

	// IsTypeConditionContext differentiates from other interfaces.
	IsTypeConditionContext()
}

type TypeConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConditionContext() *TypeConditionContext {
	var p = new(TypeConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeCondition
	return p
}

func (*TypeConditionContext) IsTypeConditionContext() {}

func NewTypeConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConditionContext {
	var p = new(TypeConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeCondition

	return p
}

func (s *TypeConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConditionContext) ON_KEYWORD() antlr.TerminalNode {
	return s.GetToken(GraphqlParserON_KEYWORD, 0)
}

func (s *TypeConditionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeCondition(s)
	}
}

func (s *TypeConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeCondition(s)
	}
}

func (s *TypeConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeCondition() (localctx ITypeConditionContext) {
	this := p
	_ = this

	localctx = NewTypeConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GraphqlParserRULE_typeCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(GraphqlParserON_KEYWORD)
	}
	{
		p.SetState(381)
		p.TypeName()
	}

	return localctx
}

// IDocumentContext is an interface to support dynamic dispatch.
type IDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOperationDefinition() []IOperationDefinitionContext
	OperationDefinition(i int) IOperationDefinitionContext
	AllFragmentDefinition() []IFragmentDefinitionContext
	FragmentDefinition(i int) IFragmentDefinitionContext

	// IsDocumentContext differentiates from other interfaces.
	IsDocumentContext()
}

type DocumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentContext() *DocumentContext {
	var p = new(DocumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_document
	return p
}

func (*DocumentContext) IsDocumentContext() {}

func NewDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentContext {
	var p = new(DocumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_document

	return p
}

func (s *DocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentContext) AllOperationDefinition() []IOperationDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperationDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOperationDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperationDefinitionContext); ok {
			tst[i] = t.(IOperationDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *DocumentContext) OperationDefinition(i int) IOperationDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationDefinitionContext)
}

func (s *DocumentContext) AllFragmentDefinition() []IFragmentDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFragmentDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFragmentDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFragmentDefinitionContext); ok {
			tst[i] = t.(IFragmentDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *DocumentContext) FragmentDefinition(i int) IFragmentDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFragmentDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFragmentDefinitionContext)
}

func (s *DocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDocument(s)
	}
}

func (s *DocumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDocument(s)
	}
}

func (s *DocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) Document() (localctx IDocumentContext) {
	this := p
	_ = this

	localctx = NewDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GraphqlParserRULE_document)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1966088) != 0) {
		p.SetState(385)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GraphqlParserT__2, GraphqlParserQUERY, GraphqlParserMUTATION, GraphqlParserSUBSCRIPTION:
			{
				p.SetState(383)
				p.OperationDefinition()
			}

		case GraphqlParserFRAGMENT:
			{
				p.SetState(384)
				p.FragmentDefinition()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeSystemDefinitionContext is an interface to support dynamic dispatch.
type ITypeSystemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SchemaDefinition() ISchemaDefinitionContext
	TypeDefinition() ITypeDefinitionContext
	DirectiveDefinition() IDirectiveDefinitionContext

	// IsTypeSystemDefinitionContext differentiates from other interfaces.
	IsTypeSystemDefinitionContext()
}

type TypeSystemDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSystemDefinitionContext() *TypeSystemDefinitionContext {
	var p = new(TypeSystemDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeSystemDefinition
	return p
}

func (*TypeSystemDefinitionContext) IsTypeSystemDefinitionContext() {}

func NewTypeSystemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSystemDefinitionContext {
	var p = new(TypeSystemDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeSystemDefinition

	return p
}

func (s *TypeSystemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSystemDefinitionContext) SchemaDefinition() ISchemaDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaDefinitionContext)
}

func (s *TypeSystemDefinitionContext) TypeDefinition() ITypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeSystemDefinitionContext) DirectiveDefinition() IDirectiveDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveDefinitionContext)
}

func (s *TypeSystemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSystemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSystemDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeSystemDefinition(s)
	}
}

func (s *TypeSystemDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeSystemDefinition(s)
	}
}

func (s *TypeSystemDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeSystemDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeSystemDefinition() (localctx ITypeSystemDefinitionContext) {
	this := p
	_ = this

	localctx = NewTypeSystemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GraphqlParserRULE_typeSystemDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(389)
			p.SchemaDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(390)
			p.TypeDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(391)
			p.DirectiveDefinition()
		}

	}

	return localctx
}

// ITypeSystemExtensionContext is an interface to support dynamic dispatch.
type ITypeSystemExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SchemaExtension() ISchemaExtensionContext
	TypeExtension() ITypeExtensionContext

	// IsTypeSystemExtensionContext differentiates from other interfaces.
	IsTypeSystemExtensionContext()
}

type TypeSystemExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSystemExtensionContext() *TypeSystemExtensionContext {
	var p = new(TypeSystemExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeSystemExtension
	return p
}

func (*TypeSystemExtensionContext) IsTypeSystemExtensionContext() {}

func NewTypeSystemExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSystemExtensionContext {
	var p = new(TypeSystemExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeSystemExtension

	return p
}

func (s *TypeSystemExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSystemExtensionContext) SchemaExtension() ISchemaExtensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaExtensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaExtensionContext)
}

func (s *TypeSystemExtensionContext) TypeExtension() ITypeExtensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeExtensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeExtensionContext)
}

func (s *TypeSystemExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSystemExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSystemExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeSystemExtension(s)
	}
}

func (s *TypeSystemExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeSystemExtension(s)
	}
}

func (s *TypeSystemExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeSystemExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeSystemExtension() (localctx ITypeSystemExtensionContext) {
	this := p
	_ = this

	localctx = NewTypeSystemExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GraphqlParserRULE_typeSystemExtension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.SchemaExtension()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(395)
			p.TypeExtension()
		}

	}

	return localctx
}

// ISchemaDefinitionContext is an interface to support dynamic dispatch.
type ISchemaDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEMA() antlr.TerminalNode
	Description() IDescriptionContext
	Directives() IDirectivesContext
	AllOperationTypeDefinition() []IOperationTypeDefinitionContext
	OperationTypeDefinition(i int) IOperationTypeDefinitionContext

	// IsSchemaDefinitionContext differentiates from other interfaces.
	IsSchemaDefinitionContext()
}

type SchemaDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaDefinitionContext() *SchemaDefinitionContext {
	var p = new(SchemaDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_schemaDefinition
	return p
}

func (*SchemaDefinitionContext) IsSchemaDefinitionContext() {}

func NewSchemaDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaDefinitionContext {
	var p = new(SchemaDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_schemaDefinition

	return p
}

func (s *SchemaDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaDefinitionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCHEMA, 0)
}

func (s *SchemaDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *SchemaDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *SchemaDefinitionContext) AllOperationTypeDefinition() []IOperationTypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperationTypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOperationTypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperationTypeDefinitionContext); ok {
			tst[i] = t.(IOperationTypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SchemaDefinitionContext) OperationTypeDefinition(i int) IOperationTypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationTypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationTypeDefinitionContext)
}

func (s *SchemaDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterSchemaDefinition(s)
	}
}

func (s *SchemaDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitSchemaDefinition(s)
	}
}

func (s *SchemaDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitSchemaDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) SchemaDefinition() (localctx ISchemaDefinitionContext) {
	this := p
	_ = this

	localctx = NewSchemaDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GraphqlParserRULE_schemaDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(398)
			p.Description()
		}

	}
	{
		p.SetState(401)
		p.Match(GraphqlParserSCHEMA)
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(402)
			p.Directives()
		}

	}
	{
		p.SetState(405)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68721311744) != 0) {
		{
			p.SetState(406)
			p.OperationTypeDefinition()
		}

		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(411)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// ISchemaExtensionContext is an interface to support dynamic dispatch.
type ISchemaExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	AllDirectives() []IDirectivesContext
	Directives(i int) IDirectivesContext
	AllOperationTypeDefinition() []IOperationTypeDefinitionContext
	OperationTypeDefinition(i int) IOperationTypeDefinitionContext

	// IsSchemaExtensionContext differentiates from other interfaces.
	IsSchemaExtensionContext()
}

type SchemaExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaExtensionContext() *SchemaExtensionContext {
	var p = new(SchemaExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_schemaExtension
	return p
}

func (*SchemaExtensionContext) IsSchemaExtensionContext() {}

func NewSchemaExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaExtensionContext {
	var p = new(SchemaExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_schemaExtension

	return p
}

func (s *SchemaExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaExtensionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *SchemaExtensionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCHEMA, 0)
}

func (s *SchemaExtensionContext) AllDirectives() []IDirectivesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectivesContext); ok {
			len++
		}
	}

	tst := make([]IDirectivesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectivesContext); ok {
			tst[i] = t.(IDirectivesContext)
			i++
		}
	}

	return tst
}

func (s *SchemaExtensionContext) Directives(i int) IDirectivesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *SchemaExtensionContext) AllOperationTypeDefinition() []IOperationTypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperationTypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOperationTypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperationTypeDefinitionContext); ok {
			tst[i] = t.(IOperationTypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *SchemaExtensionContext) OperationTypeDefinition(i int) IOperationTypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationTypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationTypeDefinitionContext)
}

func (s *SchemaExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterSchemaExtension(s)
	}
}

func (s *SchemaExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitSchemaExtension(s)
	}
}

func (s *SchemaExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitSchemaExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) SchemaExtension() (localctx ISchemaExtensionContext) {
	this := p
	_ = this

	localctx = NewSchemaExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GraphqlParserRULE_schemaExtension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(413)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(414)
			p.Match(GraphqlParserSCHEMA)
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(415)
				p.Directives()
			}

		}
		{
			p.SetState(418)
			p.Match(GraphqlParserT__2)
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68721311744) != 0) {
			{
				p.SetState(419)
				p.OperationTypeDefinition()
			}

			p.SetState(422)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(424)
			p.Match(GraphqlParserT__3)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(426)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(427)
			p.Match(GraphqlParserSCHEMA)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == GraphqlParserT__5 {
			{
				p.SetState(428)
				p.Directives()
			}

			p.SetState(431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOperationTypeDefinitionContext is an interface to support dynamic dispatch.
type IOperationTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OperationType() IOperationTypeContext
	TypeName() ITypeNameContext
	Description() IDescriptionContext

	// IsOperationTypeDefinitionContext differentiates from other interfaces.
	IsOperationTypeDefinitionContext()
}

type OperationTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationTypeDefinitionContext() *OperationTypeDefinitionContext {
	var p = new(OperationTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_operationTypeDefinition
	return p
}

func (*OperationTypeDefinitionContext) IsOperationTypeDefinitionContext() {}

func NewOperationTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationTypeDefinitionContext {
	var p = new(OperationTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_operationTypeDefinition

	return p
}

func (s *OperationTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationTypeDefinitionContext) OperationType() IOperationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationTypeContext)
}

func (s *OperationTypeDefinitionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *OperationTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *OperationTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterOperationTypeDefinition(s)
	}
}

func (s *OperationTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitOperationTypeDefinition(s)
	}
}

func (s *OperationTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitOperationTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) OperationTypeDefinition() (localctx IOperationTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewOperationTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GraphqlParserRULE_operationTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(435)
			p.Description()
		}

	}
	{
		p.SetState(438)
		p.OperationType()
	}
	{
		p.SetState(439)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(440)
		p.TypeName()
	}

	return localctx
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarTypeDefinition() IScalarTypeDefinitionContext
	ObjectTypeDefinition() IObjectTypeDefinitionContext
	InterfaceTypeDefinition() IInterfaceTypeDefinitionContext
	UnionTypeDefinition() IUnionTypeDefinitionContext
	EnumTypeDefinition() IEnumTypeDefinitionContext
	InputObjectTypeDefinition() IInputObjectTypeDefinitionContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeDefinition
	return p
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) ScalarTypeDefinition() IScalarTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeDefinitionContext)
}

func (s *TypeDefinitionContext) ObjectTypeDefinition() IObjectTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeDefinitionContext)
}

func (s *TypeDefinitionContext) InterfaceTypeDefinition() IInterfaceTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeDefinitionContext)
}

func (s *TypeDefinitionContext) UnionTypeDefinition() IUnionTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionTypeDefinitionContext)
}

func (s *TypeDefinitionContext) EnumTypeDefinition() IEnumTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumTypeDefinitionContext)
}

func (s *TypeDefinitionContext) InputObjectTypeDefinition() IInputObjectTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputObjectTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputObjectTypeDefinitionContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GraphqlParserRULE_typeDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(442)
			p.ScalarTypeDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(443)
			p.ObjectTypeDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(444)
			p.InterfaceTypeDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(445)
			p.UnionTypeDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(446)
			p.EnumTypeDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(447)
			p.InputObjectTypeDefinition()
		}

	}

	return localctx
}

// ITypeExtensionContext is an interface to support dynamic dispatch.
type ITypeExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ObjectTypeExtensionDefinition() IObjectTypeExtensionDefinitionContext
	InterfaceTypeExtensionDefinition() IInterfaceTypeExtensionDefinitionContext
	UnionTypeExtensionDefinition() IUnionTypeExtensionDefinitionContext
	ScalarTypeExtensionDefinition() IScalarTypeExtensionDefinitionContext
	EnumTypeExtensionDefinition() IEnumTypeExtensionDefinitionContext
	InputObjectTypeExtensionDefinition() IInputObjectTypeExtensionDefinitionContext

	// IsTypeExtensionContext differentiates from other interfaces.
	IsTypeExtensionContext()
}

type TypeExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeExtensionContext() *TypeExtensionContext {
	var p = new(TypeExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_typeExtension
	return p
}

func (*TypeExtensionContext) IsTypeExtensionContext() {}

func NewTypeExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeExtensionContext {
	var p = new(TypeExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_typeExtension

	return p
}

func (s *TypeExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeExtensionContext) ObjectTypeExtensionDefinition() IObjectTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) InterfaceTypeExtensionDefinition() IInterfaceTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) UnionTypeExtensionDefinition() IUnionTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) ScalarTypeExtensionDefinition() IScalarTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) EnumTypeExtensionDefinition() IEnumTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) InputObjectTypeExtensionDefinition() IInputObjectTypeExtensionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputObjectTypeExtensionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputObjectTypeExtensionDefinitionContext)
}

func (s *TypeExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterTypeExtension(s)
	}
}

func (s *TypeExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitTypeExtension(s)
	}
}

func (s *TypeExtensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitTypeExtension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) TypeExtension() (localctx ITypeExtensionContext) {
	this := p
	_ = this

	localctx = NewTypeExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GraphqlParserRULE_typeExtension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.ObjectTypeExtensionDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(451)
			p.InterfaceTypeExtensionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(452)
			p.UnionTypeExtensionDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(453)
			p.ScalarTypeExtensionDefinition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(454)
			p.EnumTypeExtensionDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(455)
			p.InputObjectTypeExtensionDefinition()
		}

	}

	return localctx
}

// IEmptyParenthesesContext is an interface to support dynamic dispatch.
type IEmptyParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyParenthesesContext differentiates from other interfaces.
	IsEmptyParenthesesContext()
}

type EmptyParenthesesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyParenthesesContext() *EmptyParenthesesContext {
	var p = new(EmptyParenthesesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_emptyParentheses
	return p
}

func (*EmptyParenthesesContext) IsEmptyParenthesesContext() {}

func NewEmptyParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyParenthesesContext {
	var p = new(EmptyParenthesesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_emptyParentheses

	return p
}

func (s *EmptyParenthesesContext) GetParser() antlr.Parser { return s.parser }
func (s *EmptyParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEmptyParentheses(s)
	}
}

func (s *EmptyParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEmptyParentheses(s)
	}
}

func (s *EmptyParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEmptyParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EmptyParentheses() (localctx IEmptyParenthesesContext) {
	this := p
	_ = this

	localctx = NewEmptyParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GraphqlParserRULE_emptyParentheses)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(GraphqlParserT__2)
	}
	{
		p.SetState(459)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IScalarTypeDefinitionContext is an interface to support dynamic dispatch.
type IScalarTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCALAR() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsScalarTypeDefinitionContext differentiates from other interfaces.
	IsScalarTypeDefinitionContext()
}

type ScalarTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeDefinitionContext() *ScalarTypeDefinitionContext {
	var p = new(ScalarTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_scalarTypeDefinition
	return p
}

func (*ScalarTypeDefinitionContext) IsScalarTypeDefinitionContext() {}

func NewScalarTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeDefinitionContext {
	var p = new(ScalarTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_scalarTypeDefinition

	return p
}

func (s *ScalarTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeDefinitionContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCALAR, 0)
}

func (s *ScalarTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ScalarTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *ScalarTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *ScalarTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterScalarTypeDefinition(s)
	}
}

func (s *ScalarTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitScalarTypeDefinition(s)
	}
}

func (s *ScalarTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitScalarTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ScalarTypeDefinition() (localctx IScalarTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewScalarTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GraphqlParserRULE_scalarTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(461)
			p.Description()
		}

	}
	{
		p.SetState(464)
		p.Match(GraphqlParserSCALAR)
	}
	{
		p.SetState(465)
		p.Name()
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(466)
			p.Directives()
		}

	}

	return localctx
}

// IScalarTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IScalarTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	SCALAR() antlr.TerminalNode
	Name() INameContext
	Directives() IDirectivesContext

	// IsScalarTypeExtensionDefinitionContext differentiates from other interfaces.
	IsScalarTypeExtensionDefinitionContext()
}

type ScalarTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeExtensionDefinitionContext() *ScalarTypeExtensionDefinitionContext {
	var p = new(ScalarTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_scalarTypeExtensionDefinition
	return p
}

func (*ScalarTypeExtensionDefinitionContext) IsScalarTypeExtensionDefinitionContext() {}

func NewScalarTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeExtensionDefinitionContext {
	var p = new(ScalarTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_scalarTypeExtensionDefinition

	return p
}

func (s *ScalarTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *ScalarTypeExtensionDefinitionContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(GraphqlParserSCALAR, 0)
}

func (s *ScalarTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ScalarTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *ScalarTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterScalarTypeExtensionDefinition(s)
	}
}

func (s *ScalarTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitScalarTypeExtensionDefinition(s)
	}
}

func (s *ScalarTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitScalarTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ScalarTypeExtensionDefinition() (localctx IScalarTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewScalarTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GraphqlParserRULE_scalarTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(GraphqlParserEXTEND)
	}
	{
		p.SetState(470)
		p.Match(GraphqlParserSCALAR)
	}
	{
		p.SetState(471)
		p.Name()
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(472)
			p.Directives()
		}

	}

	return localctx
}

// IObjectTypeDefinitionContext is an interface to support dynamic dispatch.
type IObjectTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	ImplementsInterfaces() IImplementsInterfacesContext
	Directives() IDirectivesContext
	FieldsDefinition() IFieldsDefinitionContext

	// IsObjectTypeDefinitionContext differentiates from other interfaces.
	IsObjectTypeDefinitionContext()
}

type ObjectTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeDefinitionContext() *ObjectTypeDefinitionContext {
	var p = new(ObjectTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectTypeDefinition
	return p
}

func (*ObjectTypeDefinitionContext) IsObjectTypeDefinitionContext() {}

func NewObjectTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeDefinitionContext {
	var p = new(ObjectTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectTypeDefinition

	return p
}

func (s *ObjectTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeDefinitionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserTYPE, 0)
}

func (s *ObjectTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ObjectTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *ObjectTypeDefinitionContext) ImplementsInterfaces() IImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsInterfacesContext)
}

func (s *ObjectTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *ObjectTypeDefinitionContext) FieldsDefinition() IFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsDefinitionContext)
}

func (s *ObjectTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectTypeDefinition(s)
	}
}

func (s *ObjectTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectTypeDefinition(s)
	}
}

func (s *ObjectTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectTypeDefinition() (localctx IObjectTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewObjectTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GraphqlParserRULE_objectTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(475)
			p.Description()
		}

	}
	{
		p.SetState(478)
		p.Match(GraphqlParserTYPE)
	}
	{
		p.SetState(479)
		p.Name()
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserIMPLEMENTS {
		{
			p.SetState(480)
			p.implementsInterfaces(0)
		}

	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(483)
			p.Directives()
		}

	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__2 {
		{
			p.SetState(486)
			p.FieldsDefinition()
		}

	}

	return localctx
}

// IObjectTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IObjectTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	Name() INameContext
	ExtensionFieldsDefinition() IExtensionFieldsDefinitionContext
	ImplementsInterfaces() IImplementsInterfacesContext
	Directives() IDirectivesContext
	EmptyParentheses() IEmptyParenthesesContext

	// IsObjectTypeExtensionDefinitionContext differentiates from other interfaces.
	IsObjectTypeExtensionDefinitionContext()
}

type ObjectTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeExtensionDefinitionContext() *ObjectTypeExtensionDefinitionContext {
	var p = new(ObjectTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_objectTypeExtensionDefinition
	return p
}

func (*ObjectTypeExtensionDefinitionContext) IsObjectTypeExtensionDefinitionContext() {}

func NewObjectTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeExtensionDefinitionContext {
	var p = new(ObjectTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_objectTypeExtensionDefinition

	return p
}

func (s *ObjectTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *ObjectTypeExtensionDefinitionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserTYPE, 0)
}

func (s *ObjectTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ObjectTypeExtensionDefinitionContext) ExtensionFieldsDefinition() IExtensionFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionFieldsDefinitionContext)
}

func (s *ObjectTypeExtensionDefinitionContext) ImplementsInterfaces() IImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsInterfacesContext)
}

func (s *ObjectTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *ObjectTypeExtensionDefinitionContext) EmptyParentheses() IEmptyParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyParenthesesContext)
}

func (s *ObjectTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterObjectTypeExtensionDefinition(s)
	}
}

func (s *ObjectTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitObjectTypeExtensionDefinition(s)
	}
}

func (s *ObjectTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitObjectTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ObjectTypeExtensionDefinition() (localctx IObjectTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewObjectTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GraphqlParserRULE_objectTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(489)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(490)
			p.Match(GraphqlParserTYPE)
		}
		{
			p.SetState(491)
			p.Name()
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(492)
				p.implementsInterfaces(0)
			}

		}
		p.SetState(496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(495)
				p.Directives()
			}

		}
		{
			p.SetState(498)
			p.ExtensionFieldsDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(501)
			p.Match(GraphqlParserTYPE)
		}
		{
			p.SetState(502)
			p.Name()
		}
		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(503)
				p.implementsInterfaces(0)
			}

		}
		{
			p.SetState(506)
			p.Directives()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(507)
				p.EmptyParentheses()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(510)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(511)
			p.Match(GraphqlParserTYPE)
		}
		{
			p.SetState(512)
			p.Name()
		}
		{
			p.SetState(513)
			p.implementsInterfaces(0)
		}

	}

	return localctx
}

// IImplementsInterfacesContext is an interface to support dynamic dispatch.
type IImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTS() antlr.TerminalNode
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	ImplementsInterfaces() IImplementsInterfacesContext

	// IsImplementsInterfacesContext differentiates from other interfaces.
	IsImplementsInterfacesContext()
}

type ImplementsInterfacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsInterfacesContext() *ImplementsInterfacesContext {
	var p = new(ImplementsInterfacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_implementsInterfaces
	return p
}

func (*ImplementsInterfacesContext) IsImplementsInterfacesContext() {}

func NewImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsInterfacesContext {
	var p = new(ImplementsInterfacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_implementsInterfaces

	return p
}

func (s *ImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsInterfacesContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GraphqlParserIMPLEMENTS, 0)
}

func (s *ImplementsInterfacesContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *ImplementsInterfacesContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ImplementsInterfacesContext) ImplementsInterfaces() IImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsInterfacesContext)
}

func (s *ImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterImplementsInterfaces(s)
	}
}

func (s *ImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitImplementsInterfaces(s)
	}
}

func (s *ImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ImplementsInterfaces() (localctx IImplementsInterfacesContext) {
	return p.implementsInterfaces(0)
}

func (p *GraphqlParser) implementsInterfaces(_p int) (localctx IImplementsInterfacesContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewImplementsInterfacesContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IImplementsInterfacesContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, GraphqlParserRULE_implementsInterfaces, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.Match(GraphqlParserIMPLEMENTS)
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__12 {
		{
			p.SetState(519)
			p.Match(GraphqlParserT__12)
		}

	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(522)
				p.TypeName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewImplementsInterfacesContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GraphqlParserRULE_implementsInterfaces)
			p.SetState(527)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(528)
				p.Match(GraphqlParserT__12)
			}
			{
				p.SetState(529)
				p.TypeName()
			}

		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}

	return localctx
}

// IFieldsDefinitionContext is an interface to support dynamic dispatch.
type IFieldsDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDefinition() []IFieldDefinitionContext
	FieldDefinition(i int) IFieldDefinitionContext

	// IsFieldsDefinitionContext differentiates from other interfaces.
	IsFieldsDefinitionContext()
}

type FieldsDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsDefinitionContext() *FieldsDefinitionContext {
	var p = new(FieldsDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_fieldsDefinition
	return p
}

func (*FieldsDefinitionContext) IsFieldsDefinitionContext() {}

func NewFieldsDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsDefinitionContext {
	var p = new(FieldsDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_fieldsDefinition

	return p
}

func (s *FieldsDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsDefinitionContext) AllFieldDefinition() []IFieldDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFieldDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDefinitionContext); ok {
			tst[i] = t.(IFieldDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *FieldsDefinitionContext) FieldDefinition(i int) IFieldDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefinitionContext)
}

func (s *FieldsDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterFieldsDefinition(s)
	}
}

func (s *FieldsDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitFieldsDefinition(s)
	}
}

func (s *FieldsDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitFieldsDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) FieldsDefinition() (localctx IFieldsDefinitionContext) {
	this := p
	_ = this

	localctx = NewFieldsDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GraphqlParserRULE_fieldsDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899313152) != 0 {
		{
			p.SetState(536)
			p.FieldDefinition()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(542)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IExtensionFieldsDefinitionContext is an interface to support dynamic dispatch.
type IExtensionFieldsDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDefinition() []IFieldDefinitionContext
	FieldDefinition(i int) IFieldDefinitionContext

	// IsExtensionFieldsDefinitionContext differentiates from other interfaces.
	IsExtensionFieldsDefinitionContext()
}

type ExtensionFieldsDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionFieldsDefinitionContext() *ExtensionFieldsDefinitionContext {
	var p = new(ExtensionFieldsDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_extensionFieldsDefinition
	return p
}

func (*ExtensionFieldsDefinitionContext) IsExtensionFieldsDefinitionContext() {}

func NewExtensionFieldsDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionFieldsDefinitionContext {
	var p = new(ExtensionFieldsDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_extensionFieldsDefinition

	return p
}

func (s *ExtensionFieldsDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionFieldsDefinitionContext) AllFieldDefinition() []IFieldDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFieldDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDefinitionContext); ok {
			tst[i] = t.(IFieldDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionFieldsDefinitionContext) FieldDefinition(i int) IFieldDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefinitionContext)
}

func (s *ExtensionFieldsDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionFieldsDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionFieldsDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterExtensionFieldsDefinition(s)
	}
}

func (s *ExtensionFieldsDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitExtensionFieldsDefinition(s)
	}
}

func (s *ExtensionFieldsDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitExtensionFieldsDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ExtensionFieldsDefinition() (localctx IExtensionFieldsDefinitionContext) {
	this := p
	_ = this

	localctx = NewExtensionFieldsDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GraphqlParserRULE_extensionFieldsDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899313152) != 0) {
		{
			p.SetState(545)
			p.FieldDefinition()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(550)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IFieldDefinitionContext is an interface to support dynamic dispatch.
type IFieldDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	GqlType() IGqlTypeContext
	Description() IDescriptionContext
	ArgumentsDefinition() IArgumentsDefinitionContext
	Directives() IDirectivesContext

	// IsFieldDefinitionContext differentiates from other interfaces.
	IsFieldDefinitionContext()
}

type FieldDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDefinitionContext() *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_fieldDefinition
	return p
}

func (*FieldDefinitionContext) IsFieldDefinitionContext() {}

func NewFieldDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_fieldDefinition

	return p
}

func (s *FieldDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FieldDefinitionContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *FieldDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *FieldDefinitionContext) ArgumentsDefinition() IArgumentsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsDefinitionContext)
}

func (s *FieldDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *FieldDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterFieldDefinition(s)
	}
}

func (s *FieldDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitFieldDefinition(s)
	}
}

func (s *FieldDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitFieldDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) FieldDefinition() (localctx IFieldDefinitionContext) {
	this := p
	_ = this

	localctx = NewFieldDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GraphqlParserRULE_fieldDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(552)
			p.Description()
		}

	}
	{
		p.SetState(555)
		p.Name()
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__6 {
		{
			p.SetState(556)
			p.ArgumentsDefinition()
		}

	}
	{
		p.SetState(559)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(560)
		p.GqlType()
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(561)
			p.Directives()
		}

	}

	return localctx
}

// IArgumentsDefinitionContext is an interface to support dynamic dispatch.
type IArgumentsDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInputValueDefinition() []IInputValueDefinitionContext
	InputValueDefinition(i int) IInputValueDefinitionContext

	// IsArgumentsDefinitionContext differentiates from other interfaces.
	IsArgumentsDefinitionContext()
}

type ArgumentsDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsDefinitionContext() *ArgumentsDefinitionContext {
	var p = new(ArgumentsDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_argumentsDefinition
	return p
}

func (*ArgumentsDefinitionContext) IsArgumentsDefinitionContext() {}

func NewArgumentsDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsDefinitionContext {
	var p = new(ArgumentsDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_argumentsDefinition

	return p
}

func (s *ArgumentsDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsDefinitionContext) AllInputValueDefinition() []IInputValueDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IInputValueDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInputValueDefinitionContext); ok {
			tst[i] = t.(IInputValueDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsDefinitionContext) InputValueDefinition(i int) IInputValueDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputValueDefinitionContext)
}

func (s *ArgumentsDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterArgumentsDefinition(s)
	}
}

func (s *ArgumentsDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitArgumentsDefinition(s)
	}
}

func (s *ArgumentsDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitArgumentsDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ArgumentsDefinition() (localctx IArgumentsDefinitionContext) {
	this := p
	_ = this

	localctx = NewArgumentsDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GraphqlParserRULE_argumentsDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(GraphqlParserT__6)
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899313152) != 0) {
		{
			p.SetState(565)
			p.InputValueDefinition()
		}

		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(570)
		p.Match(GraphqlParserT__7)
	}

	return localctx
}

// IInputValueDefinitionContext is an interface to support dynamic dispatch.
type IInputValueDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	GqlType() IGqlTypeContext
	Description() IDescriptionContext
	DefaultValue() IDefaultValueContext
	Directives() IDirectivesContext

	// IsInputValueDefinitionContext differentiates from other interfaces.
	IsInputValueDefinitionContext()
}

type InputValueDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputValueDefinitionContext() *InputValueDefinitionContext {
	var p = new(InputValueDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_inputValueDefinition
	return p
}

func (*InputValueDefinitionContext) IsInputValueDefinitionContext() {}

func NewInputValueDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputValueDefinitionContext {
	var p = new(InputValueDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_inputValueDefinition

	return p
}

func (s *InputValueDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputValueDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InputValueDefinitionContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *InputValueDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *InputValueDefinitionContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *InputValueDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InputValueDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputValueDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputValueDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInputValueDefinition(s)
	}
}

func (s *InputValueDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInputValueDefinition(s)
	}
}

func (s *InputValueDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInputValueDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InputValueDefinition() (localctx IInputValueDefinitionContext) {
	this := p
	_ = this

	localctx = NewInputValueDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GraphqlParserRULE_inputValueDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(572)
			p.Description()
		}

	}
	{
		p.SetState(575)
		p.Name()
	}
	{
		p.SetState(576)
		p.Match(GraphqlParserT__4)
	}
	{
		p.SetState(577)
		p.GqlType()
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__9 {
		{
			p.SetState(578)
			p.DefaultValue()
		}

	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(581)
			p.Directives()
		}

	}

	return localctx
}

// IInterfaceTypeDefinitionContext is an interface to support dynamic dispatch.
type IInterfaceTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	Directives() IDirectivesContext
	FieldsDefinition() IFieldsDefinitionContext

	// IsInterfaceTypeDefinitionContext differentiates from other interfaces.
	IsInterfaceTypeDefinitionContext()
}

type InterfaceTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeDefinitionContext() *InterfaceTypeDefinitionContext {
	var p = new(InterfaceTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_interfaceTypeDefinition
	return p
}

func (*InterfaceTypeDefinitionContext) IsInterfaceTypeDefinitionContext() {}

func NewInterfaceTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeDefinitionContext {
	var p = new(InterfaceTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_interfaceTypeDefinition

	return p
}

func (s *InterfaceTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeDefinitionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINTERFACE, 0)
}

func (s *InterfaceTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InterfaceTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *InterfaceTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InterfaceTypeDefinitionContext) FieldsDefinition() IFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsDefinitionContext)
}

func (s *InterfaceTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInterfaceTypeDefinition(s)
	}
}

func (s *InterfaceTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInterfaceTypeDefinition(s)
	}
}

func (s *InterfaceTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInterfaceTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InterfaceTypeDefinition() (localctx IInterfaceTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewInterfaceTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GraphqlParserRULE_interfaceTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(584)
			p.Description()
		}

	}
	{
		p.SetState(587)
		p.Match(GraphqlParserINTERFACE)
	}
	{
		p.SetState(588)
		p.Name()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(589)
			p.Directives()
		}

	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__2 {
		{
			p.SetState(592)
			p.FieldsDefinition()
		}

	}

	return localctx
}

// IInterfaceTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IInterfaceTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	Name() INameContext
	ExtensionFieldsDefinition() IExtensionFieldsDefinitionContext
	ImplementsInterfaces() IImplementsInterfacesContext
	Directives() IDirectivesContext
	EmptyParentheses() IEmptyParenthesesContext

	// IsInterfaceTypeExtensionDefinitionContext differentiates from other interfaces.
	IsInterfaceTypeExtensionDefinitionContext()
}

type InterfaceTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeExtensionDefinitionContext() *InterfaceTypeExtensionDefinitionContext {
	var p = new(InterfaceTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_interfaceTypeExtensionDefinition
	return p
}

func (*InterfaceTypeExtensionDefinitionContext) IsInterfaceTypeExtensionDefinitionContext() {}

func NewInterfaceTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeExtensionDefinitionContext {
	var p = new(InterfaceTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_interfaceTypeExtensionDefinition

	return p
}

func (s *InterfaceTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *InterfaceTypeExtensionDefinitionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINTERFACE, 0)
}

func (s *InterfaceTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InterfaceTypeExtensionDefinitionContext) ExtensionFieldsDefinition() IExtensionFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionFieldsDefinitionContext)
}

func (s *InterfaceTypeExtensionDefinitionContext) ImplementsInterfaces() IImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsInterfacesContext)
}

func (s *InterfaceTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InterfaceTypeExtensionDefinitionContext) EmptyParentheses() IEmptyParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyParenthesesContext)
}

func (s *InterfaceTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInterfaceTypeExtensionDefinition(s)
	}
}

func (s *InterfaceTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInterfaceTypeExtensionDefinition(s)
	}
}

func (s *InterfaceTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInterfaceTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InterfaceTypeExtensionDefinition() (localctx IInterfaceTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewInterfaceTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GraphqlParserRULE_interfaceTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(595)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(596)
			p.Match(GraphqlParserINTERFACE)
		}
		{
			p.SetState(597)
			p.Name()
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(598)
				p.implementsInterfaces(0)
			}

		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(601)
				p.Directives()
			}

		}
		{
			p.SetState(604)
			p.ExtensionFieldsDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(606)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(607)
			p.Match(GraphqlParserINTERFACE)
		}
		{
			p.SetState(608)
			p.Name()
		}
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(609)
				p.implementsInterfaces(0)
			}

		}
		{
			p.SetState(612)
			p.Directives()
		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(613)
				p.EmptyParentheses()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(616)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(617)
			p.Match(GraphqlParserINTERFACE)
		}
		{
			p.SetState(618)
			p.Name()
		}
		{
			p.SetState(619)
			p.implementsInterfaces(0)
		}

	}

	return localctx
}

// IUnionTypeDefinitionContext is an interface to support dynamic dispatch.
type IUnionTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	Name() INameContext
	UnionMembership() IUnionMembershipContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsUnionTypeDefinitionContext differentiates from other interfaces.
	IsUnionTypeDefinitionContext()
}

type UnionTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeDefinitionContext() *UnionTypeDefinitionContext {
	var p = new(UnionTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_unionTypeDefinition
	return p
}

func (*UnionTypeDefinitionContext) IsUnionTypeDefinitionContext() {}

func NewUnionTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeDefinitionContext {
	var p = new(UnionTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_unionTypeDefinition

	return p
}

func (s *UnionTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeDefinitionContext) UNION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserUNION, 0)
}

func (s *UnionTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *UnionTypeDefinitionContext) UnionMembership() IUnionMembershipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionMembershipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionMembershipContext)
}

func (s *UnionTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *UnionTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *UnionTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterUnionTypeDefinition(s)
	}
}

func (s *UnionTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitUnionTypeDefinition(s)
	}
}

func (s *UnionTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitUnionTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) UnionTypeDefinition() (localctx IUnionTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewUnionTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GraphqlParserRULE_unionTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(623)
			p.Description()
		}

	}
	{
		p.SetState(626)
		p.Match(GraphqlParserUNION)
	}
	{
		p.SetState(627)
		p.Name()
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(628)
			p.Directives()
		}

	}
	{
		p.SetState(631)
		p.UnionMembership()
	}

	return localctx
}

// IUnionTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IUnionTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	UNION() antlr.TerminalNode
	Name() INameContext
	UnionMembership() IUnionMembershipContext
	Directives() IDirectivesContext

	// IsUnionTypeExtensionDefinitionContext differentiates from other interfaces.
	IsUnionTypeExtensionDefinitionContext()
}

type UnionTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeExtensionDefinitionContext() *UnionTypeExtensionDefinitionContext {
	var p = new(UnionTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_unionTypeExtensionDefinition
	return p
}

func (*UnionTypeExtensionDefinitionContext) IsUnionTypeExtensionDefinitionContext() {}

func NewUnionTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeExtensionDefinitionContext {
	var p = new(UnionTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_unionTypeExtensionDefinition

	return p
}

func (s *UnionTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *UnionTypeExtensionDefinitionContext) UNION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserUNION, 0)
}

func (s *UnionTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *UnionTypeExtensionDefinitionContext) UnionMembership() IUnionMembershipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionMembershipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionMembershipContext)
}

func (s *UnionTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *UnionTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterUnionTypeExtensionDefinition(s)
	}
}

func (s *UnionTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitUnionTypeExtensionDefinition(s)
	}
}

func (s *UnionTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitUnionTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) UnionTypeExtensionDefinition() (localctx IUnionTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewUnionTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GraphqlParserRULE_unionTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(633)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(634)
			p.Match(GraphqlParserUNION)
		}
		{
			p.SetState(635)
			p.Name()
		}
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(636)
				p.Directives()
			}

		}
		{
			p.SetState(639)
			p.UnionMembership()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(642)
			p.Match(GraphqlParserUNION)
		}
		{
			p.SetState(643)
			p.Name()
		}
		{
			p.SetState(644)
			p.Directives()
		}

	}

	return localctx
}

// IUnionMembershipContext is an interface to support dynamic dispatch.
type IUnionMembershipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnionMembers() IUnionMembersContext

	// IsUnionMembershipContext differentiates from other interfaces.
	IsUnionMembershipContext()
}

type UnionMembershipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMembershipContext() *UnionMembershipContext {
	var p = new(UnionMembershipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_unionMembership
	return p
}

func (*UnionMembershipContext) IsUnionMembershipContext() {}

func NewUnionMembershipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMembershipContext {
	var p = new(UnionMembershipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_unionMembership

	return p
}

func (s *UnionMembershipContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMembershipContext) UnionMembers() IUnionMembersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionMembersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionMembersContext)
}

func (s *UnionMembershipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMembershipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMembershipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterUnionMembership(s)
	}
}

func (s *UnionMembershipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitUnionMembership(s)
	}
}

func (s *UnionMembershipContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitUnionMembership(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) UnionMembership() (localctx IUnionMembershipContext) {
	this := p
	_ = this

	localctx = NewUnionMembershipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GraphqlParserRULE_unionMembership)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(GraphqlParserT__9)
	}
	{
		p.SetState(649)
		p.unionMembers(0)
	}

	return localctx
}

// IUnionMembersContext is an interface to support dynamic dispatch.
type IUnionMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	UnionMembers() IUnionMembersContext

	// IsUnionMembersContext differentiates from other interfaces.
	IsUnionMembersContext()
}

type UnionMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMembersContext() *UnionMembersContext {
	var p = new(UnionMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_unionMembers
	return p
}

func (*UnionMembersContext) IsUnionMembersContext() {}

func NewUnionMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMembersContext {
	var p = new(UnionMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_unionMembers

	return p
}

func (s *UnionMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMembersContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *UnionMembersContext) UnionMembers() IUnionMembersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionMembersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionMembersContext)
}

func (s *UnionMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterUnionMembers(s)
	}
}

func (s *UnionMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitUnionMembers(s)
	}
}

func (s *UnionMembersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitUnionMembers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) UnionMembers() (localctx IUnionMembersContext) {
	return p.unionMembers(0)
}

func (p *GraphqlParser) unionMembers(_p int) (localctx IUnionMembersContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewUnionMembersContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IUnionMembersContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, GraphqlParserRULE_unionMembers, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__13 {
		{
			p.SetState(652)
			p.Match(GraphqlParserT__13)
		}

	}
	{
		p.SetState(655)
		p.TypeName()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewUnionMembersContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GraphqlParserRULE_unionMembers)
			p.SetState(657)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(658)
				p.Match(GraphqlParserT__13)
			}
			{
				p.SetState(659)
				p.TypeName()
			}

		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumTypeDefinitionContext is an interface to support dynamic dispatch.
type IEnumTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	Directives() IDirectivesContext
	EnumValueDefinitions() IEnumValueDefinitionsContext

	// IsEnumTypeDefinitionContext differentiates from other interfaces.
	IsEnumTypeDefinitionContext()
}

type EnumTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumTypeDefinitionContext() *EnumTypeDefinitionContext {
	var p = new(EnumTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumTypeDefinition
	return p
}

func (*EnumTypeDefinitionContext) IsEnumTypeDefinitionContext() {}

func NewEnumTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumTypeDefinitionContext {
	var p = new(EnumTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumTypeDefinition

	return p
}

func (s *EnumTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumTypeDefinitionContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GraphqlParserENUM, 0)
}

func (s *EnumTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *EnumTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *EnumTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *EnumTypeDefinitionContext) EnumValueDefinitions() IEnumValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueDefinitionsContext)
}

func (s *EnumTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumTypeDefinition(s)
	}
}

func (s *EnumTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumTypeDefinition(s)
	}
}

func (s *EnumTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumTypeDefinition() (localctx IEnumTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GraphqlParserRULE_enumTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(665)
			p.Description()
		}

	}
	{
		p.SetState(668)
		p.Match(GraphqlParserENUM)
	}
	{
		p.SetState(669)
		p.Name()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(670)
			p.Directives()
		}

	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__2 {
		{
			p.SetState(673)
			p.EnumValueDefinitions()
		}

	}

	return localctx
}

// IEnumTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IEnumTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	Name() INameContext
	ExtensionEnumValueDefinitions() IExtensionEnumValueDefinitionsContext
	Directives() IDirectivesContext
	EmptyParentheses() IEmptyParenthesesContext

	// IsEnumTypeExtensionDefinitionContext differentiates from other interfaces.
	IsEnumTypeExtensionDefinitionContext()
}

type EnumTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumTypeExtensionDefinitionContext() *EnumTypeExtensionDefinitionContext {
	var p = new(EnumTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumTypeExtensionDefinition
	return p
}

func (*EnumTypeExtensionDefinitionContext) IsEnumTypeExtensionDefinitionContext() {}

func NewEnumTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumTypeExtensionDefinitionContext {
	var p = new(EnumTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumTypeExtensionDefinition

	return p
}

func (s *EnumTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *EnumTypeExtensionDefinitionContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GraphqlParserENUM, 0)
}

func (s *EnumTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *EnumTypeExtensionDefinitionContext) ExtensionEnumValueDefinitions() IExtensionEnumValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionEnumValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionEnumValueDefinitionsContext)
}

func (s *EnumTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *EnumTypeExtensionDefinitionContext) EmptyParentheses() IEmptyParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyParenthesesContext)
}

func (s *EnumTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumTypeExtensionDefinition(s)
	}
}

func (s *EnumTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumTypeExtensionDefinition(s)
	}
}

func (s *EnumTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumTypeExtensionDefinition() (localctx IEnumTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GraphqlParserRULE_enumTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(676)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(677)
			p.Match(GraphqlParserENUM)
		}
		{
			p.SetState(678)
			p.Name()
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(679)
				p.Directives()
			}

		}
		{
			p.SetState(682)
			p.ExtensionEnumValueDefinitions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(684)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(685)
			p.Match(GraphqlParserENUM)
		}
		{
			p.SetState(686)
			p.Name()
		}
		{
			p.SetState(687)
			p.Directives()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(688)
				p.EmptyParentheses()
			}

		}

	}

	return localctx
}

// IEnumValueDefinitionsContext is an interface to support dynamic dispatch.
type IEnumValueDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumValueDefinition() []IEnumValueDefinitionContext
	EnumValueDefinition(i int) IEnumValueDefinitionContext

	// IsEnumValueDefinitionsContext differentiates from other interfaces.
	IsEnumValueDefinitionsContext()
}

type EnumValueDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueDefinitionsContext() *EnumValueDefinitionsContext {
	var p = new(EnumValueDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumValueDefinitions
	return p
}

func (*EnumValueDefinitionsContext) IsEnumValueDefinitionsContext() {}

func NewEnumValueDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueDefinitionsContext {
	var p = new(EnumValueDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumValueDefinitions

	return p
}

func (s *EnumValueDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueDefinitionsContext) AllEnumValueDefinition() []IEnumValueDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueDefinitionContext); ok {
			tst[i] = t.(IEnumValueDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *EnumValueDefinitionsContext) EnumValueDefinition(i int) IEnumValueDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueDefinitionContext)
}

func (s *EnumValueDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumValueDefinitions(s)
	}
}

func (s *EnumValueDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumValueDefinitions(s)
	}
}

func (s *EnumValueDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumValueDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumValueDefinitions() (localctx IEnumValueDefinitionsContext) {
	this := p
	_ = this

	localctx = NewEnumValueDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GraphqlParserRULE_enumValueDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899214848) != 0 {
		{
			p.SetState(694)
			p.EnumValueDefinition()
		}

		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(700)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IExtensionEnumValueDefinitionsContext is an interface to support dynamic dispatch.
type IExtensionEnumValueDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumValueDefinition() []IEnumValueDefinitionContext
	EnumValueDefinition(i int) IEnumValueDefinitionContext

	// IsExtensionEnumValueDefinitionsContext differentiates from other interfaces.
	IsExtensionEnumValueDefinitionsContext()
}

type ExtensionEnumValueDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionEnumValueDefinitionsContext() *ExtensionEnumValueDefinitionsContext {
	var p = new(ExtensionEnumValueDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_extensionEnumValueDefinitions
	return p
}

func (*ExtensionEnumValueDefinitionsContext) IsExtensionEnumValueDefinitionsContext() {}

func NewExtensionEnumValueDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionEnumValueDefinitionsContext {
	var p = new(ExtensionEnumValueDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_extensionEnumValueDefinitions

	return p
}

func (s *ExtensionEnumValueDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionEnumValueDefinitionsContext) AllEnumValueDefinition() []IEnumValueDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueDefinitionContext); ok {
			tst[i] = t.(IEnumValueDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionEnumValueDefinitionsContext) EnumValueDefinition(i int) IEnumValueDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueDefinitionContext)
}

func (s *ExtensionEnumValueDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionEnumValueDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionEnumValueDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterExtensionEnumValueDefinitions(s)
	}
}

func (s *ExtensionEnumValueDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitExtensionEnumValueDefinitions(s)
	}
}

func (s *ExtensionEnumValueDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitExtensionEnumValueDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ExtensionEnumValueDefinitions() (localctx IExtensionEnumValueDefinitionsContext) {
	this := p
	_ = this

	localctx = NewExtensionEnumValueDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GraphqlParserRULE_extensionEnumValueDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899214848) != 0) {
		{
			p.SetState(703)
			p.EnumValueDefinition()
		}

		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(708)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IEnumValueDefinitionContext is an interface to support dynamic dispatch.
type IEnumValueDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumValue() IEnumValueContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsEnumValueDefinitionContext differentiates from other interfaces.
	IsEnumValueDefinitionContext()
}

type EnumValueDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueDefinitionContext() *EnumValueDefinitionContext {
	var p = new(EnumValueDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_enumValueDefinition
	return p
}

func (*EnumValueDefinitionContext) IsEnumValueDefinitionContext() {}

func NewEnumValueDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueDefinitionContext {
	var p = new(EnumValueDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_enumValueDefinition

	return p
}

func (s *EnumValueDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueDefinitionContext) EnumValue() IEnumValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumValueDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *EnumValueDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *EnumValueDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterEnumValueDefinition(s)
	}
}

func (s *EnumValueDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitEnumValueDefinition(s)
	}
}

func (s *EnumValueDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitEnumValueDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) EnumValueDefinition() (localctx IEnumValueDefinitionContext) {
	this := p
	_ = this

	localctx = NewEnumValueDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GraphqlParserRULE_enumValueDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(710)
			p.Description()
		}

	}
	{
		p.SetState(713)
		p.EnumValue()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(714)
			p.Directives()
		}

	}

	return localctx
}

// IInputObjectTypeDefinitionContext is an interface to support dynamic dispatch.
type IInputObjectTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INPUT() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	Directives() IDirectivesContext
	InputObjectValueDefinitions() IInputObjectValueDefinitionsContext

	// IsInputObjectTypeDefinitionContext differentiates from other interfaces.
	IsInputObjectTypeDefinitionContext()
}

type InputObjectTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputObjectTypeDefinitionContext() *InputObjectTypeDefinitionContext {
	var p = new(InputObjectTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_inputObjectTypeDefinition
	return p
}

func (*InputObjectTypeDefinitionContext) IsInputObjectTypeDefinitionContext() {}

func NewInputObjectTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputObjectTypeDefinitionContext {
	var p = new(InputObjectTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_inputObjectTypeDefinition

	return p
}

func (s *InputObjectTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputObjectTypeDefinitionContext) INPUT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINPUT, 0)
}

func (s *InputObjectTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InputObjectTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *InputObjectTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InputObjectTypeDefinitionContext) InputObjectValueDefinitions() IInputObjectValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputObjectValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputObjectValueDefinitionsContext)
}

func (s *InputObjectTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputObjectTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputObjectTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInputObjectTypeDefinition(s)
	}
}

func (s *InputObjectTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInputObjectTypeDefinition(s)
	}
}

func (s *InputObjectTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInputObjectTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InputObjectTypeDefinition() (localctx IInputObjectTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewInputObjectTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GraphqlParserRULE_inputObjectTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(717)
			p.Description()
		}

	}
	{
		p.SetState(720)
		p.Match(GraphqlParserINPUT)
	}
	{
		p.SetState(721)
		p.Name()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(722)
			p.Directives()
		}

	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__2 {
		{
			p.SetState(725)
			p.InputObjectValueDefinitions()
		}

	}

	return localctx
}

// IInputObjectTypeExtensionDefinitionContext is an interface to support dynamic dispatch.
type IInputObjectTypeExtensionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	Name() INameContext
	ExtensionInputObjectValueDefinitions() IExtensionInputObjectValueDefinitionsContext
	Directives() IDirectivesContext
	EmptyParentheses() IEmptyParenthesesContext

	// IsInputObjectTypeExtensionDefinitionContext differentiates from other interfaces.
	IsInputObjectTypeExtensionDefinitionContext()
}

type InputObjectTypeExtensionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputObjectTypeExtensionDefinitionContext() *InputObjectTypeExtensionDefinitionContext {
	var p = new(InputObjectTypeExtensionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_inputObjectTypeExtensionDefinition
	return p
}

func (*InputObjectTypeExtensionDefinitionContext) IsInputObjectTypeExtensionDefinitionContext() {}

func NewInputObjectTypeExtensionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputObjectTypeExtensionDefinitionContext {
	var p = new(InputObjectTypeExtensionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_inputObjectTypeExtensionDefinition

	return p
}

func (s *InputObjectTypeExtensionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputObjectTypeExtensionDefinitionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(GraphqlParserEXTEND, 0)
}

func (s *InputObjectTypeExtensionDefinitionContext) INPUT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINPUT, 0)
}

func (s *InputObjectTypeExtensionDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *InputObjectTypeExtensionDefinitionContext) ExtensionInputObjectValueDefinitions() IExtensionInputObjectValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensionInputObjectValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensionInputObjectValueDefinitionsContext)
}

func (s *InputObjectTypeExtensionDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *InputObjectTypeExtensionDefinitionContext) EmptyParentheses() IEmptyParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyParenthesesContext)
}

func (s *InputObjectTypeExtensionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputObjectTypeExtensionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputObjectTypeExtensionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInputObjectTypeExtensionDefinition(s)
	}
}

func (s *InputObjectTypeExtensionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInputObjectTypeExtensionDefinition(s)
	}
}

func (s *InputObjectTypeExtensionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInputObjectTypeExtensionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InputObjectTypeExtensionDefinition() (localctx IInputObjectTypeExtensionDefinitionContext) {
	this := p
	_ = this

	localctx = NewInputObjectTypeExtensionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GraphqlParserRULE_inputObjectTypeExtensionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(728)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(729)
			p.Match(GraphqlParserINPUT)
		}
		{
			p.SetState(730)
			p.Name()
		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(731)
				p.Directives()
			}

		}
		{
			p.SetState(734)
			p.ExtensionInputObjectValueDefinitions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(736)
			p.Match(GraphqlParserEXTEND)
		}
		{
			p.SetState(737)
			p.Match(GraphqlParserINPUT)
		}
		{
			p.SetState(738)
			p.Name()
		}
		{
			p.SetState(739)
			p.Directives()
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(740)
				p.EmptyParentheses()
			}

		}

	}

	return localctx
}

// IInputObjectValueDefinitionsContext is an interface to support dynamic dispatch.
type IInputObjectValueDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInputValueDefinition() []IInputValueDefinitionContext
	InputValueDefinition(i int) IInputValueDefinitionContext

	// IsInputObjectValueDefinitionsContext differentiates from other interfaces.
	IsInputObjectValueDefinitionsContext()
}

type InputObjectValueDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputObjectValueDefinitionsContext() *InputObjectValueDefinitionsContext {
	var p = new(InputObjectValueDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_inputObjectValueDefinitions
	return p
}

func (*InputObjectValueDefinitionsContext) IsInputObjectValueDefinitionsContext() {}

func NewInputObjectValueDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputObjectValueDefinitionsContext {
	var p = new(InputObjectValueDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_inputObjectValueDefinitions

	return p
}

func (s *InputObjectValueDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *InputObjectValueDefinitionsContext) AllInputValueDefinition() []IInputValueDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IInputValueDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInputValueDefinitionContext); ok {
			tst[i] = t.(IInputValueDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *InputObjectValueDefinitionsContext) InputValueDefinition(i int) IInputValueDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputValueDefinitionContext)
}

func (s *InputObjectValueDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputObjectValueDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputObjectValueDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterInputObjectValueDefinitions(s)
	}
}

func (s *InputObjectValueDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitInputObjectValueDefinitions(s)
	}
}

func (s *InputObjectValueDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitInputObjectValueDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) InputObjectValueDefinitions() (localctx IInputObjectValueDefinitionsContext) {
	this := p
	_ = this

	localctx = NewInputObjectValueDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GraphqlParserRULE_inputObjectValueDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899313152) != 0 {
		{
			p.SetState(746)
			p.InputValueDefinition()
		}

		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(752)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IExtensionInputObjectValueDefinitionsContext is an interface to support dynamic dispatch.
type IExtensionInputObjectValueDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInputValueDefinition() []IInputValueDefinitionContext
	InputValueDefinition(i int) IInputValueDefinitionContext

	// IsExtensionInputObjectValueDefinitionsContext differentiates from other interfaces.
	IsExtensionInputObjectValueDefinitionsContext()
}

type ExtensionInputObjectValueDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionInputObjectValueDefinitionsContext() *ExtensionInputObjectValueDefinitionsContext {
	var p = new(ExtensionInputObjectValueDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_extensionInputObjectValueDefinitions
	return p
}

func (*ExtensionInputObjectValueDefinitionsContext) IsExtensionInputObjectValueDefinitionsContext() {}

func NewExtensionInputObjectValueDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionInputObjectValueDefinitionsContext {
	var p = new(ExtensionInputObjectValueDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_extensionInputObjectValueDefinitions

	return p
}

func (s *ExtensionInputObjectValueDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionInputObjectValueDefinitionsContext) AllInputValueDefinition() []IInputValueDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IInputValueDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInputValueDefinitionContext); ok {
			tst[i] = t.(IInputValueDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ExtensionInputObjectValueDefinitionsContext) InputValueDefinition(i int) IInputValueDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputValueDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputValueDefinitionContext)
}

func (s *ExtensionInputObjectValueDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionInputObjectValueDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionInputObjectValueDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterExtensionInputObjectValueDefinitions(s)
	}
}

func (s *ExtensionInputObjectValueDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitExtensionInputObjectValueDefinitions(s)
	}
}

func (s *ExtensionInputObjectValueDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitExtensionInputObjectValueDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) ExtensionInputObjectValueDefinitions() (localctx IExtensionInputObjectValueDefinitionsContext) {
	this := p
	_ = this

	localctx = NewExtensionInputObjectValueDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GraphqlParserRULE_extensionInputObjectValueDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(GraphqlParserT__2)
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&85899313152) != 0) {
		{
			p.SetState(755)
			p.InputValueDefinition()
		}

		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(760)
		p.Match(GraphqlParserT__3)
	}

	return localctx
}

// IDirectiveDefinitionContext is an interface to support dynamic dispatch.
type IDirectiveDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIRECTIVE() antlr.TerminalNode
	Name() INameContext
	ON_KEYWORD() antlr.TerminalNode
	DirectiveLocations() IDirectiveLocationsContext
	Description() IDescriptionContext
	ArgumentsDefinition() IArgumentsDefinitionContext
	REPEATABLE() antlr.TerminalNode

	// IsDirectiveDefinitionContext differentiates from other interfaces.
	IsDirectiveDefinitionContext()
}

type DirectiveDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveDefinitionContext() *DirectiveDefinitionContext {
	var p = new(DirectiveDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_directiveDefinition
	return p
}

func (*DirectiveDefinitionContext) IsDirectiveDefinitionContext() {}

func NewDirectiveDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveDefinitionContext {
	var p = new(DirectiveDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_directiveDefinition

	return p
}

func (s *DirectiveDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveDefinitionContext) DIRECTIVE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserDIRECTIVE, 0)
}

func (s *DirectiveDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *DirectiveDefinitionContext) ON_KEYWORD() antlr.TerminalNode {
	return s.GetToken(GraphqlParserON_KEYWORD, 0)
}

func (s *DirectiveDefinitionContext) DirectiveLocations() IDirectiveLocationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveLocationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveLocationsContext)
}

func (s *DirectiveDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *DirectiveDefinitionContext) ArgumentsDefinition() IArgumentsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsDefinitionContext)
}

func (s *DirectiveDefinitionContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserREPEATABLE, 0)
}

func (s *DirectiveDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDirectiveDefinition(s)
	}
}

func (s *DirectiveDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDirectiveDefinition(s)
	}
}

func (s *DirectiveDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDirectiveDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) DirectiveDefinition() (localctx IDirectiveDefinitionContext) {
	this := p
	_ = this

	localctx = NewDirectiveDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GraphqlParserRULE_directiveDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(762)
			p.Description()
		}

	}
	{
		p.SetState(765)
		p.Match(GraphqlParserDIRECTIVE)
	}
	{
		p.SetState(766)
		p.Match(GraphqlParserT__5)
	}
	{
		p.SetState(767)
		p.Name()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__6 {
		{
			p.SetState(768)
			p.ArgumentsDefinition()
		}

	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserREPEATABLE {
		{
			p.SetState(771)
			p.Match(GraphqlParserREPEATABLE)
		}

	}
	{
		p.SetState(774)
		p.Match(GraphqlParserON_KEYWORD)
	}
	{
		p.SetState(775)
		p.directiveLocations(0)
	}

	return localctx
}

// IDirectiveLocationContext is an interface to support dynamic dispatch.
type IDirectiveLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsDirectiveLocationContext differentiates from other interfaces.
	IsDirectiveLocationContext()
}

type DirectiveLocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveLocationContext() *DirectiveLocationContext {
	var p = new(DirectiveLocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_directiveLocation
	return p
}

func (*DirectiveLocationContext) IsDirectiveLocationContext() {}

func NewDirectiveLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveLocationContext {
	var p = new(DirectiveLocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_directiveLocation

	return p
}

func (s *DirectiveLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveLocationContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *DirectiveLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDirectiveLocation(s)
	}
}

func (s *DirectiveLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDirectiveLocation(s)
	}
}

func (s *DirectiveLocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDirectiveLocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) DirectiveLocation() (localctx IDirectiveLocationContext) {
	this := p
	_ = this

	localctx = NewDirectiveLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GraphqlParserRULE_directiveLocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Name()
	}

	return localctx
}

// IDirectiveLocationsContext is an interface to support dynamic dispatch.
type IDirectiveLocationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DirectiveLocation() IDirectiveLocationContext
	DirectiveLocations() IDirectiveLocationsContext

	// IsDirectiveLocationsContext differentiates from other interfaces.
	IsDirectiveLocationsContext()
}

type DirectiveLocationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveLocationsContext() *DirectiveLocationsContext {
	var p = new(DirectiveLocationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_directiveLocations
	return p
}

func (*DirectiveLocationsContext) IsDirectiveLocationsContext() {}

func NewDirectiveLocationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveLocationsContext {
	var p = new(DirectiveLocationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_directiveLocations

	return p
}

func (s *DirectiveLocationsContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveLocationsContext) DirectiveLocation() IDirectiveLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveLocationContext)
}

func (s *DirectiveLocationsContext) DirectiveLocations() IDirectiveLocationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectiveLocationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectiveLocationsContext)
}

func (s *DirectiveLocationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveLocationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveLocationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterDirectiveLocations(s)
	}
}

func (s *DirectiveLocationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitDirectiveLocations(s)
	}
}

func (s *DirectiveLocationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitDirectiveLocations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) DirectiveLocations() (localctx IDirectiveLocationsContext) {
	return p.directiveLocations(0)
}

func (p *GraphqlParser) directiveLocations(_p int) (localctx IDirectiveLocationsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDirectiveLocationsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDirectiveLocationsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 144
	p.EnterRecursionRule(localctx, 144, GraphqlParserRULE_directiveLocations, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__13 {
		{
			p.SetState(780)
			p.Match(GraphqlParserT__13)
		}

	}
	{
		p.SetState(783)
		p.DirectiveLocation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDirectiveLocationsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GraphqlParserRULE_directiveLocations)
			p.SetState(785)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(786)
				p.Match(GraphqlParserT__13)
			}
			{
				p.SetState(787)
				p.DirectiveLocation()
			}

		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}

// IPartialFieldDefinitionContext is an interface to support dynamic dispatch.
type IPartialFieldDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	GqlType() IGqlTypeContext
	ArgumentsDefinition() IArgumentsDefinitionContext
	Directives() IDirectivesContext

	// IsPartialFieldDefinitionContext differentiates from other interfaces.
	IsPartialFieldDefinitionContext()
}

type PartialFieldDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialFieldDefinitionContext() *PartialFieldDefinitionContext {
	var p = new(PartialFieldDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialFieldDefinition
	return p
}

func (*PartialFieldDefinitionContext) IsPartialFieldDefinitionContext() {}

func NewPartialFieldDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialFieldDefinitionContext {
	var p = new(PartialFieldDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialFieldDefinition

	return p
}

func (s *PartialFieldDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialFieldDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialFieldDefinitionContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *PartialFieldDefinitionContext) ArgumentsDefinition() IArgumentsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsDefinitionContext)
}

func (s *PartialFieldDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialFieldDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialFieldDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialFieldDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialFieldDefinition(s)
	}
}

func (s *PartialFieldDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialFieldDefinition(s)
	}
}

func (s *PartialFieldDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialFieldDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialFieldDefinition() (localctx IPartialFieldDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialFieldDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GraphqlParserRULE_partialFieldDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(793)
			p.Name()
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__6 {
			{
				p.SetState(794)
				p.ArgumentsDefinition()
			}

		}
		{
			p.SetState(797)
			p.Match(GraphqlParserT__4)
		}
		{
			p.SetState(798)
			p.GqlType()
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(799)
				p.Directives()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(802)
			p.ArgumentsDefinition()
		}
		{
			p.SetState(803)
			p.Match(GraphqlParserT__4)
		}
		{
			p.SetState(804)
			p.GqlType()
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(805)
				p.Directives()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(808)
			p.Name()
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__6 {
			{
				p.SetState(809)
				p.ArgumentsDefinition()
			}

		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(812)
				p.Directives()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(815)
			p.Match(GraphqlParserT__4)
		}
		{
			p.SetState(816)
			p.GqlType()
		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(817)
				p.Directives()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(820)
			p.ArgumentsDefinition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(821)
			p.Directives()
		}

	}

	return localctx
}

// IPartialObjectTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialObjectTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	ImplementsInterfaces() IImplementsInterfacesContext
	Directives() IDirectivesContext
	FieldsDefinition() IFieldsDefinitionContext

	// IsPartialObjectTypeDefinitionContext differentiates from other interfaces.
	IsPartialObjectTypeDefinitionContext()
}

type PartialObjectTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialObjectTypeDefinitionContext() *PartialObjectTypeDefinitionContext {
	var p = new(PartialObjectTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialObjectTypeDefinition
	return p
}

func (*PartialObjectTypeDefinitionContext) IsPartialObjectTypeDefinitionContext() {}

func NewPartialObjectTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialObjectTypeDefinitionContext {
	var p = new(PartialObjectTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialObjectTypeDefinition

	return p
}

func (s *PartialObjectTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialObjectTypeDefinitionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserTYPE, 0)
}

func (s *PartialObjectTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialObjectTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialObjectTypeDefinitionContext) ImplementsInterfaces() IImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsInterfacesContext)
}

func (s *PartialObjectTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialObjectTypeDefinitionContext) FieldsDefinition() IFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsDefinitionContext)
}

func (s *PartialObjectTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialObjectTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialObjectTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialObjectTypeDefinition(s)
	}
}

func (s *PartialObjectTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialObjectTypeDefinition(s)
	}
}

func (s *PartialObjectTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialObjectTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialObjectTypeDefinition() (localctx IPartialObjectTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialObjectTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GraphqlParserRULE_partialObjectTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(824)
				p.Description()
			}

		}
		{
			p.SetState(827)
			p.Match(GraphqlParserTYPE)
		}
		{
			p.SetState(828)
			p.Name()
		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(829)
				p.implementsInterfaces(0)
			}

		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(832)
				p.Directives()
			}

		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(835)
				p.FieldsDefinition()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(838)
				p.Description()
			}

		}
		{
			p.SetState(841)
			p.Name()
		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(842)
				p.implementsInterfaces(0)
			}

		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(845)
				p.Directives()
			}

		}
		p.SetState(849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(848)
				p.FieldsDefinition()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(851)
				p.Description()
			}

		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserIMPLEMENTS {
			{
				p.SetState(854)
				p.implementsInterfaces(0)
			}

		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(857)
				p.Directives()
			}

		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__2 {
			{
				p.SetState(860)
				p.FieldsDefinition()
			}

		}

	}

	return localctx
}

// IPartialInputObjectTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialInputObjectTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INPUT() antlr.TerminalNode
	Name() INameContext
	InputObjectValueDefinitions() IInputObjectValueDefinitionsContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsPartialInputObjectTypeDefinitionContext differentiates from other interfaces.
	IsPartialInputObjectTypeDefinitionContext()
}

type PartialInputObjectTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInputObjectTypeDefinitionContext() *PartialInputObjectTypeDefinitionContext {
	var p = new(PartialInputObjectTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialInputObjectTypeDefinition
	return p
}

func (*PartialInputObjectTypeDefinitionContext) IsPartialInputObjectTypeDefinitionContext() {}

func NewPartialInputObjectTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInputObjectTypeDefinitionContext {
	var p = new(PartialInputObjectTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialInputObjectTypeDefinition

	return p
}

func (s *PartialInputObjectTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInputObjectTypeDefinitionContext) INPUT() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINPUT, 0)
}

func (s *PartialInputObjectTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialInputObjectTypeDefinitionContext) InputObjectValueDefinitions() IInputObjectValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputObjectValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputObjectValueDefinitionsContext)
}

func (s *PartialInputObjectTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialInputObjectTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialInputObjectTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInputObjectTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInputObjectTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialInputObjectTypeDefinition(s)
	}
}

func (s *PartialInputObjectTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialInputObjectTypeDefinition(s)
	}
}

func (s *PartialInputObjectTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialInputObjectTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialInputObjectTypeDefinition() (localctx IPartialInputObjectTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialInputObjectTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GraphqlParserRULE_partialInputObjectTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(865)
				p.Description()
			}

		}
		{
			p.SetState(868)
			p.Match(GraphqlParserINPUT)
		}
		{
			p.SetState(869)
			p.Name()
		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(870)
				p.Directives()
			}

		}
		{
			p.SetState(873)
			p.InputObjectValueDefinitions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(875)
				p.Description()
			}

		}
		{
			p.SetState(878)
			p.Name()
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(879)
				p.Directives()
			}

		}
		{
			p.SetState(882)
			p.InputObjectValueDefinitions()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(884)
				p.Description()
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(887)
				p.Directives()
			}

		}
		{
			p.SetState(890)
			p.InputObjectValueDefinitions()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(891)
				p.Description()
			}

		}
		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(894)
				p.Directives()
			}

		}

	}

	return localctx
}

// IPartialInputValueDefinitionContext is an interface to support dynamic dispatch.
type IPartialInputValueDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	GqlType() IGqlTypeContext
	Description() IDescriptionContext
	DefaultValue() IDefaultValueContext
	Directives() IDirectivesContext

	// IsPartialInputValueDefinitionContext differentiates from other interfaces.
	IsPartialInputValueDefinitionContext()
}

type PartialInputValueDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInputValueDefinitionContext() *PartialInputValueDefinitionContext {
	var p = new(PartialInputValueDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialInputValueDefinition
	return p
}

func (*PartialInputValueDefinitionContext) IsPartialInputValueDefinitionContext() {}

func NewPartialInputValueDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInputValueDefinitionContext {
	var p = new(PartialInputValueDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialInputValueDefinition

	return p
}

func (s *PartialInputValueDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInputValueDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialInputValueDefinitionContext) GqlType() IGqlTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGqlTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGqlTypeContext)
}

func (s *PartialInputValueDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialInputValueDefinitionContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *PartialInputValueDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialInputValueDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInputValueDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInputValueDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialInputValueDefinition(s)
	}
}

func (s *PartialInputValueDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialInputValueDefinition(s)
	}
}

func (s *PartialInputValueDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialInputValueDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialInputValueDefinition() (localctx IPartialInputValueDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialInputValueDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GraphqlParserRULE_partialInputValueDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(899)
				p.Description()
			}

		}
		{
			p.SetState(902)
			p.Name()
		}
		{
			p.SetState(903)
			p.Match(GraphqlParserT__4)
		}
		{
			p.SetState(904)
			p.GqlType()
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(905)
				p.DefaultValue()
			}

		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(908)
				p.Directives()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(911)
				p.Description()
			}

		}
		{
			p.SetState(914)
			p.Name()
		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(915)
				p.DefaultValue()
			}

		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(918)
				p.Directives()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(921)
				p.Description()
			}

		}
		{
			p.SetState(924)
			p.Match(GraphqlParserT__4)
		}
		{
			p.SetState(925)
			p.GqlType()
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(926)
				p.DefaultValue()
			}

		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(929)
				p.Directives()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(932)
				p.Description()
			}

		}
		{
			p.SetState(935)
			p.DefaultValue()
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(936)
				p.Directives()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(939)
				p.Description()
			}

		}
		{
			p.SetState(942)
			p.Directives()
		}

	}

	return localctx
}

// IPartialEnumTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialEnumTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Name() INameContext
	EnumValueDefinitions() IEnumValueDefinitionsContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsPartialEnumTypeDefinitionContext differentiates from other interfaces.
	IsPartialEnumTypeDefinitionContext()
}

type PartialEnumTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialEnumTypeDefinitionContext() *PartialEnumTypeDefinitionContext {
	var p = new(PartialEnumTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialEnumTypeDefinition
	return p
}

func (*PartialEnumTypeDefinitionContext) IsPartialEnumTypeDefinitionContext() {}

func NewPartialEnumTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialEnumTypeDefinitionContext {
	var p = new(PartialEnumTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialEnumTypeDefinition

	return p
}

func (s *PartialEnumTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialEnumTypeDefinitionContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GraphqlParserENUM, 0)
}

func (s *PartialEnumTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialEnumTypeDefinitionContext) EnumValueDefinitions() IEnumValueDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueDefinitionsContext)
}

func (s *PartialEnumTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialEnumTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialEnumTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialEnumTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialEnumTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialEnumTypeDefinition(s)
	}
}

func (s *PartialEnumTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialEnumTypeDefinition(s)
	}
}

func (s *PartialEnumTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialEnumTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialEnumTypeDefinition() (localctx IPartialEnumTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialEnumTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GraphqlParserRULE_partialEnumTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(945)
				p.Description()
			}

		}
		{
			p.SetState(948)
			p.Match(GraphqlParserENUM)
		}
		{
			p.SetState(949)
			p.Name()
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(950)
				p.Directives()
			}

		}
		{
			p.SetState(953)
			p.EnumValueDefinitions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(955)
				p.Description()
			}

		}
		{
			p.SetState(958)
			p.Name()
		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(959)
				p.Directives()
			}

		}
		{
			p.SetState(962)
			p.EnumValueDefinitions()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(964)
				p.Description()
			}

		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(967)
				p.Directives()
			}

		}
		{
			p.SetState(970)
			p.EnumValueDefinitions()
		}

	}

	return localctx
}

// IPartialInterfaceTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialInterfaceTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	Name() INameContext
	FieldsDefinition() IFieldsDefinitionContext
	Description() IDescriptionContext
	Directives() IDirectivesContext

	// IsPartialInterfaceTypeDefinitionContext differentiates from other interfaces.
	IsPartialInterfaceTypeDefinitionContext()
}

type PartialInterfaceTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceTypeDefinitionContext() *PartialInterfaceTypeDefinitionContext {
	var p = new(PartialInterfaceTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialInterfaceTypeDefinition
	return p
}

func (*PartialInterfaceTypeDefinitionContext) IsPartialInterfaceTypeDefinitionContext() {}

func NewPartialInterfaceTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceTypeDefinitionContext {
	var p = new(PartialInterfaceTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialInterfaceTypeDefinition

	return p
}

func (s *PartialInterfaceTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceTypeDefinitionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GraphqlParserINTERFACE, 0)
}

func (s *PartialInterfaceTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialInterfaceTypeDefinitionContext) FieldsDefinition() IFieldsDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsDefinitionContext)
}

func (s *PartialInterfaceTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialInterfaceTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialInterfaceTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialInterfaceTypeDefinition(s)
	}
}

func (s *PartialInterfaceTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialInterfaceTypeDefinition(s)
	}
}

func (s *PartialInterfaceTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialInterfaceTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialInterfaceTypeDefinition() (localctx IPartialInterfaceTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialInterfaceTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GraphqlParserRULE_partialInterfaceTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(973)
				p.Description()
			}

		}
		{
			p.SetState(976)
			p.Match(GraphqlParserINTERFACE)
		}
		{
			p.SetState(977)
			p.Name()
		}
		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(978)
				p.Directives()
			}

		}
		{
			p.SetState(981)
			p.FieldsDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(983)
				p.Description()
			}

		}
		{
			p.SetState(986)
			p.Name()
		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(987)
				p.Directives()
			}

		}
		{
			p.SetState(990)
			p.FieldsDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(992)
				p.Description()
			}

		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(995)
				p.Directives()
			}

		}
		{
			p.SetState(998)
			p.FieldsDefinition()
		}

	}

	return localctx
}

// IPartialUnionTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialUnionTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	Name() INameContext
	Description() IDescriptionContext
	Directives() IDirectivesContext
	UnionMembership() IUnionMembershipContext

	// IsPartialUnionTypeDefinitionContext differentiates from other interfaces.
	IsPartialUnionTypeDefinitionContext()
}

type PartialUnionTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialUnionTypeDefinitionContext() *PartialUnionTypeDefinitionContext {
	var p = new(PartialUnionTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialUnionTypeDefinition
	return p
}

func (*PartialUnionTypeDefinitionContext) IsPartialUnionTypeDefinitionContext() {}

func NewPartialUnionTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialUnionTypeDefinitionContext {
	var p = new(PartialUnionTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialUnionTypeDefinition

	return p
}

func (s *PartialUnionTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialUnionTypeDefinitionContext) UNION() antlr.TerminalNode {
	return s.GetToken(GraphqlParserUNION, 0)
}

func (s *PartialUnionTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialUnionTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialUnionTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialUnionTypeDefinitionContext) UnionMembership() IUnionMembershipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionMembershipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionMembershipContext)
}

func (s *PartialUnionTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialUnionTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialUnionTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialUnionTypeDefinition(s)
	}
}

func (s *PartialUnionTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialUnionTypeDefinition(s)
	}
}

func (s *PartialUnionTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialUnionTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialUnionTypeDefinition() (localctx IPartialUnionTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialUnionTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GraphqlParserRULE_partialUnionTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(1001)
				p.Description()
			}

		}
		{
			p.SetState(1004)
			p.Match(GraphqlParserUNION)
		}
		{
			p.SetState(1005)
			p.Name()
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(1006)
				p.Directives()
			}

		}
		p.SetState(1010)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(1009)
				p.UnionMembership()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(1012)
				p.Description()
			}

		}
		{
			p.SetState(1015)
			p.Name()
		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(1016)
				p.Directives()
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(1019)
				p.UnionMembership()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserStringValue {
			{
				p.SetState(1022)
				p.Description()
			}

		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__5 {
			{
				p.SetState(1025)
				p.Directives()
			}

		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GraphqlParserT__9 {
			{
				p.SetState(1028)
				p.UnionMembership()
			}

		}

	}

	return localctx
}

// IPartialScalarTypeDefinitionContext is an interface to support dynamic dispatch.
type IPartialScalarTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Description() IDescriptionContext
	Name() INameContext
	Directives() IDirectivesContext

	// IsPartialScalarTypeDefinitionContext differentiates from other interfaces.
	IsPartialScalarTypeDefinitionContext()
}

type PartialScalarTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialScalarTypeDefinitionContext() *PartialScalarTypeDefinitionContext {
	var p = new(PartialScalarTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = GraphqlParserRULE_partialScalarTypeDefinition
	return p
}

func (*PartialScalarTypeDefinitionContext) IsPartialScalarTypeDefinitionContext() {}

func NewPartialScalarTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialScalarTypeDefinitionContext {
	var p = new(PartialScalarTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GraphqlParserRULE_partialScalarTypeDefinition

	return p
}

func (s *PartialScalarTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialScalarTypeDefinitionContext) Description() IDescriptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescriptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *PartialScalarTypeDefinitionContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PartialScalarTypeDefinitionContext) Directives() IDirectivesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectivesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *PartialScalarTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialScalarTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialScalarTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.EnterPartialScalarTypeDefinition(s)
	}
}

func (s *PartialScalarTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GraphqlListener); ok {
		listenerT.ExitPartialScalarTypeDefinition(s)
	}
}

func (s *PartialScalarTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GraphqlVisitor:
		return t.VisitPartialScalarTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GraphqlParser) PartialScalarTypeDefinition() (localctx IPartialScalarTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialScalarTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GraphqlParserRULE_partialScalarTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserStringValue {
		{
			p.SetState(1033)
			p.Description()
		}

	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179836416) != 0 {
		{
			p.SetState(1036)
			p.Name()
		}

	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GraphqlParserT__5 {
		{
			p.SetState(1039)
			p.Directives()
		}

	}

	return localctx
}

func (p *GraphqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 49:
		var t *ImplementsInterfacesContext = nil
		if localctx != nil {
			t = localctx.(*ImplementsInterfacesContext)
		}
		return p.ImplementsInterfaces_Sempred(t, predIndex)

	case 60:
		var t *UnionMembersContext = nil
		if localctx != nil {
			t = localctx.(*UnionMembersContext)
		}
		return p.UnionMembers_Sempred(t, predIndex)

	case 72:
		var t *DirectiveLocationsContext = nil
		if localctx != nil {
			t = localctx.(*DirectiveLocationsContext)
		}
		return p.DirectiveLocations_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GraphqlParser) ImplementsInterfaces_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GraphqlParser) UnionMembers_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GraphqlParser) DirectiveLocations_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
